<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · MathOptAI.jl</title><meta name="title" content="API Reference · MathOptAI.jl"/><meta property="og:title" content="API Reference · MathOptAI.jl"/><meta property="twitter:title" content="API Reference · MathOptAI.jl"/><meta name="description" content="Documentation for MathOptAI.jl."/><meta property="og:description" content="Documentation for MathOptAI.jl."/><meta property="twitter:description" content="Documentation for MathOptAI.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MathOptAI.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">MathOptAI.jl</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../manual/predictors/">Predictors</a></li><li><a class="tocitem" href="../manual/AbstractGPs/">AbstractGPs.jl</a></li><li><a class="tocitem" href="../manual/DecisionTree/">DecisionTree.jl</a></li><li><a class="tocitem" href="../manual/EvoTrees/">EvoTrees.jl</a></li><li><a class="tocitem" href="../manual/Flux/">Flux.jl</a></li><li><a class="tocitem" href="../manual/GLM/">GLM.jl</a></li><li><a class="tocitem" href="../manual/Lux/">Lux.jl</a></li><li><a class="tocitem" href="../manual/PythonCall/">Python integration</a></li><li><a class="tocitem" href="../manual/PyTorch/">PyTorch</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/student_enrollment/">Logistic regression with GLM.jl</a></li><li><a class="tocitem" href="../tutorials/decision_trees/">Classification problems with DecisionTree.jl</a></li><li><a class="tocitem" href="../tutorials/mnist/">Adversarial machine learning with Flux.jl</a></li><li><a class="tocitem" href="../tutorials/mnist_lux/">Adversarial machine learning with Lux.jl</a></li><li><a class="tocitem" href="../tutorials/pytorch/">Function fitting with PyTorch</a></li><li><a class="tocitem" href="../tutorials/gaussian/">Function fitting with AbstractGPs</a></li><li><a class="tocitem" href="../tutorials/graph_neural_networks/">Graph neural networks</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../developers/checklists/">Checklists</a></li><li><a class="tocitem" href="../developers/design_principles/">Design principles</a></li></ul></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#AbstractPredictor"><span><code>AbstractPredictor</code></span></a></li><li><a class="tocitem" href="#add_predictor"><span><code>add_predictor</code></span></a></li><li><a class="tocitem" href="#build_predictor"><span><code>build_predictor</code></span></a></li><li><a class="tocitem" href="#output_size"><span><code>output_size</code></span></a></li><li><a class="tocitem" href="#Affine"><span><code>Affine</code></span></a></li><li><a class="tocitem" href="#AffineCombination"><span><code>AffineCombination</code></span></a></li><li><a class="tocitem" href="#AvgPool2d"><span><code>AvgPool2d</code></span></a></li><li><a class="tocitem" href="#BinaryDecisionTree"><span><code>BinaryDecisionTree</code></span></a></li><li><a class="tocitem" href="#Conv2d"><span><code>Conv2d</code></span></a></li><li><a class="tocitem" href="#GCNConv"><span><code>GCNConv</code></span></a></li><li><a class="tocitem" href="#GELU"><span><code>GELU</code></span></a></li><li><a class="tocitem" href="#GrayBox"><span><code>GrayBox</code></span></a></li><li><a class="tocitem" href="#LayerNorm"><span><code>LayerNorm</code></span></a></li><li><a class="tocitem" href="#LeakyReLU"><span><code>LeakyReLU</code></span></a></li><li><a class="tocitem" href="#MaxPool2d"><span><code>MaxPool2d</code></span></a></li><li><a class="tocitem" href="#MaxPool2dBigM"><span><code>MaxPool2dBigM</code></span></a></li><li><a class="tocitem" href="#Permutation"><span><code>Permutation</code></span></a></li><li><a class="tocitem" href="#Pipeline"><span><code>Pipeline</code></span></a></li><li><a class="tocitem" href="#PytorchModel"><span><code>PytorchModel</code></span></a></li><li><a class="tocitem" href="#Quantile"><span><code>Quantile</code></span></a></li><li><a class="tocitem" href="#ReducedSpace"><span><code>ReducedSpace</code></span></a></li><li><a class="tocitem" href="#ReLU"><span><code>ReLU</code></span></a></li><li><a class="tocitem" href="#ReLUBigM"><span><code>ReLUBigM</code></span></a></li><li><a class="tocitem" href="#ReLUQuadratic"><span><code>ReLUQuadratic</code></span></a></li><li><a class="tocitem" href="#ReLUSOS1"><span><code>ReLUSOS1</code></span></a></li><li><a class="tocitem" href="#Scale"><span><code>Scale</code></span></a></li><li><a class="tocitem" href="#Sigmoid"><span><code>Sigmoid</code></span></a></li><li><a class="tocitem" href="#SoftMax"><span><code>SoftMax</code></span></a></li><li><a class="tocitem" href="#SoftPlus"><span><code>SoftPlus</code></span></a></li><li><a class="tocitem" href="#TAGConv"><span><code>TAGConv</code></span></a></li><li><a class="tocitem" href="#Tanh"><span><code>Tanh</code></span></a></li><li><a class="tocitem" href="#AbstractFormulation"><span><code>AbstractFormulation</code></span></a></li><li><a class="tocitem" href="#Formulation"><span><code>Formulation</code></span></a></li><li><a class="tocitem" href="#PipelineFormulation"><span><code>PipelineFormulation</code></span></a></li><li><a class="tocitem" href="#AbstractGPs"><span><code>AbstractGPs</code></span></a></li><li><a class="tocitem" href="#DecisionTree"><span><code>DecisionTree</code></span></a></li><li><a class="tocitem" href="#EvoTrees"><span><code>EvoTrees</code></span></a></li><li><a class="tocitem" href="#Flux"><span><code>Flux</code></span></a></li><li><a class="tocitem" href="#GLM"><span><code>GLM</code></span></a></li><li><a class="tocitem" href="#Lux"><span><code>Lux</code></span></a></li><li><a class="tocitem" href="#PythonCall"><span><code>PythonCall</code></span></a></li><li><a class="tocitem" href="#StatsModels"><span><code>StatsModels</code></span></a></li><li><a class="tocitem" href="#Extensions"><span>Extensions</span></a></li><li><a class="tocitem" href="#replace_weights_with_variables"><span><code>replace_weights_with_variables</code></span></a></li></ul></li><li><a class="tocitem" href="../release_notes/">Release notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/lanl-ansi/MathOptAI.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><p>This page lists the public API of <code>MathOptAI</code>.</p><div class="admonition is-info" id="Info-643b2d236ef6aad0"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-643b2d236ef6aad0" title="Permalink"></a></header><div class="admonition-body"><p>This page is an unstructured list of the MathOptAI API. For a more structured overview, read the Manual or Tutorial parts of this documentation.</p></div></div><p>Load all of the public the API into the current scope with:</p><pre><code class="language-julia hljs">using MathOptAI</code></pre><p>Alternatively, load only the module with:</p><pre><code class="language-julia hljs">import MathOptAI</code></pre><p>and then prefix all calls with <code>MathOptAI.</code> to create <code>MathOptAI.&lt;NAME&gt;</code>.</p><h2 id="AbstractPredictor"><a class="docs-heading-anchor" href="#AbstractPredictor"><code>AbstractPredictor</code></a><a id="AbstractPredictor-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractPredictor" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.AbstractPredictor"><a class="docstring-binding" href="#MathOptAI.AbstractPredictor"><code>MathOptAI.AbstractPredictor</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbstractPredictor end</code></pre><p>An abstract type representing different types of prediction models.</p><p><strong>Methods</strong></p><p>All subtypes must implement:</p><ul><li><a href="#add_predictor"><code>add_predictor</code></a></li><li><a href="#build_predictor"><code>build_predictor</code></a></li></ul><p>The following methods are optional, but encouraged:</p><ul><li><a href="#output_size"><code>output_size</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/MathOptAI.jl#L13-L28">source</a></section></details></article><h2 id="add_predictor"><a class="docs-heading-anchor" href="#add_predictor"><code>add_predictor</code></a><a id="add_predictor-1"></a><a class="docs-heading-anchor-permalink" href="#add_predictor" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.add_predictor"><a class="docstring-binding" href="#MathOptAI.add_predictor"><code>MathOptAI.add_predictor</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">MathOptAI.add_predictor(
    model::JuMP.AbstractModel,
    predictor::MathOptAI.Quantile{&lt;:AbstractGPs.PosteriorGP},
    x::Vector,
)</code></pre><p>Add the quantiles of a trained Gaussian Process from AbstractGPs.jl to <code>model</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI, AbstractGPs

julia&gt; x_data = 2π .* (0.0:0.1:1.0);

julia&gt; y_data = sin.(x_data);

julia&gt; fx = AbstractGPs.GP(AbstractGPs.Matern32Kernel())(x_data, 0.1);

julia&gt; p_fx = AbstractGPs.posterior(fx, y_data);

julia&gt; model = Model();

julia&gt; @variable(model, 1 &lt;= x[1:1] &lt;= 6, start = 3);

julia&gt; predictor = MathOptAI.Quantile(p_fx, [0.1, 0.9]);

julia&gt; y, _ = MathOptAI.add_predictor(model, predictor, x);

julia&gt; y
2-element Vector{VariableRef}:
 moai_quantile[1]
 moai_quantile[2]

julia&gt; @objective(model, Max, y[2] - y[1])
moai_quantile[2] - moai_quantile[1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/ext/MathOptAIAbstractGPsExt.jl#L14-L52">source</a></section><section><div><pre><code class="language-julia hljs">MathOptAI.add_predictor(
    model::JuMP.AbstractModel,
    predictor::StatsModels.TableRegressionModel,
    x::DataFrames.DataFrame;
    kwargs...,
)</code></pre><p>Add a trained regression model from StatsModels.jl to <code>model</code>, using the DataFrame <code>x</code> as input.</p><p>In most cases, <code>predictor</code> should be a GLM.jl predictor supported by MathOptAI, but trained using <code>@formula</code> and a <code>DataFrame</code> instead of the raw matrix input.</p><p>In general, <code>x</code> may have some columns that are constant (<code>Float64</code>) and some columns that are JuMP decision variables.</p><p><strong>Keyword arguments</strong></p><p>All keyword arguments are passed to the corresponding <a href="#add_predictor"><code>add_predictor</code></a> of the GLM extension.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DataFrames, GLM, JuMP, MathOptAI

julia&gt; train_df = DataFrames.DataFrame(x1 = rand(10), x2 = rand(10));

julia&gt; train_df.y = 1.0 .* train_df.x1 + 2.0 .* train_df.x2 .+ rand(10);

julia&gt; predictor = GLM.lm(GLM.@formula(y ~ x1 + x2), train_df);

julia&gt; model = Model();

julia&gt; test_df = DataFrames.DataFrame(
           x1 = rand(6),
           x2 = @variable(model, [1:6]),
       );

julia&gt; test_df.y, _ = MathOptAI.add_predictor(model, predictor, test_df);

julia&gt; test_df.y
6-element Vector{VariableRef}:
 moai_Affine[1]
 moai_Affine[1]
 moai_Affine[1]
 moai_Affine[1]
 moai_Affine[1]
 moai_Affine[1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/ext/MathOptAIStatsModelsExt.jl#L14-L65">source</a></section><section><div><pre><code class="language-julia hljs">add_predictor(
    model::JuMP.AbstractModel,
    predictor::Any,
    x::Vector;
    reduced_space::Bool = false,
    kwargs...,
)::Tuple{&lt;:Vector,&lt;:AbstractFormulation}</code></pre><p>Return a <code>Vector</code> representing <code>y</code> such that <code>y = predictor(x)</code> and an <a href="#AbstractFormulation"><code>AbstractFormulation</code></a> containing the variables and constraints that were added to the model.</p><p>The element type of <code>x</code> is deliberately unspecified. The vector <code>x</code> may contain any mix of scalar constants, JuMP decision variables, and scalar JuMP functions like <code>AffExpr</code>, <code>QuadExpr</code>, or <code>NonlinearExpr</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>reduced_space</code>: if <code>true</code>, wrap <code>predictor</code> in <a href="#ReducedSpace"><code>ReducedSpace</code></a> before adding to the model.</li></ul><p>All other keyword arguments are passed to <a href="#build_predictor"><code>build_predictor</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI

julia&gt; model = Model();

julia&gt; @variable(model, x[1:2]);

julia&gt; f = MathOptAI.Affine([2.0, 3.0])
Affine(A, b) [input: 2, output: 1]

julia&gt; y, formulation = MathOptAI.add_predictor(model, f, x);

julia&gt; y
1-element Vector{VariableRef}:
 moai_Affine[1]

julia&gt; formulation
Affine(A, b) [input: 2, output: 1]
├ variables [1]
│ └ moai_Affine[1]
└ constraints [1]
  └ 2 x[1] + 3 x[2] - moai_Affine[1] = 0

julia&gt; y, formulation = MathOptAI.add_predictor(model, f, x; reduced_space = true);

julia&gt; y
1-element Vector{AffExpr}:
 2 x[1] + 3 x[2]

julia&gt; formulation
ReducedSpace(Affine(A, b) [input: 2, output: 1])
├ variables [0]
└ constraints [0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/MathOptAI.jl#L118-L178">source</a></section><section><div><pre><code class="language-julia hljs">add_predictor(model::JuMP.AbstractModel, predictor, x::Array; kwargs...)</code></pre><p>This method is a helper function for adding <code>predictor</code> to <code>model</code> when the input <code>x</code> is a multi-dimensional array.</p><p>It is equivalent to passing <code>vec(x)</code> with the keyword <code>input_size = size(x)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI, Flux

julia&gt; model = Model();

julia&gt; @variable(model, x[1:4, 1:4]);

julia&gt; predictor = Flux.Chain(Flux.MaxPool((2, 2)), Flux.flatten);

julia&gt; y, formulation = MathOptAI.add_predictor(model, predictor, x);

julia&gt; y
4-element Vector{VariableRef}:
 moai_MaxPool2d[1]
 moai_MaxPool2d[2]
 moai_MaxPool2d[3]
 moai_MaxPool2d[4]

julia&gt; formulation
MaxPool2d((4, 4, 1), (2, 2), (2, 2), (0, 0))
├ variables [4]
│ ├ moai_MaxPool2d[1]
│ ├ moai_MaxPool2d[2]
│ ├ moai_MaxPool2d[3]
│ └ moai_MaxPool2d[4]
└ constraints [4]
  ├ moai_MaxPool2d[1] - max(max(max(x[1,1], x[2,1]), x[1,2]), x[2,2]) = 0
  ├ moai_MaxPool2d[2] - max(max(max(x[3,1], x[4,1]), x[3,2]), x[4,2]) = 0
  ├ moai_MaxPool2d[3] - max(max(max(x[1,3], x[2,3]), x[1,4]), x[2,4]) = 0
  └ moai_MaxPool2d[4] - max(max(max(x[3,3], x[4,3]), x[3,4]), x[4,4]) = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/MathOptAI.jl#L202-L243">source</a></section></details></article><h2 id="build_predictor"><a class="docs-heading-anchor" href="#build_predictor"><code>build_predictor</code></a><a id="build_predictor-1"></a><a class="docs-heading-anchor-permalink" href="#build_predictor" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.build_predictor-Tuple{MathOptAI.AbstractPredictor}"><a class="docstring-binding" href="#MathOptAI.build_predictor-Tuple{MathOptAI.AbstractPredictor}"><code>MathOptAI.build_predictor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MathOptAI.build_predictor(predictor::EvoTrees.EvoTree{L,1}) where {L}</code></pre><p>Convert a boosted tree from EvoTrees.jl to an <a href="#AffineCombination"><code>AffineCombination</code></a> of <a href="#BinaryDecisionTree"><code>BinaryDecisionTree</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI, EvoTrees

julia&gt; truth(x::Vector) = x[1] &lt;= 0.5 ? -2 : (x[2] &lt;= 0.3 ? 3 : 4)
truth (generic function with 1 method)

julia&gt; x_train = abs.(sin.((1:10) .* (3:4)&#39;));

julia&gt; size(x_train)
(10, 2)

julia&gt; y_train = truth.(Vector.(eachrow(x_train)));

julia&gt; config = EvoTrees.EvoTreeRegressor(; nrounds = 3);

julia&gt; tree = EvoTrees.fit(config; x_train, y_train);

julia&gt; model = Model();

julia&gt; @variable(model, 0 &lt;= x[1:2] &lt;= 1);

julia&gt; y, _ = MathOptAI.add_predictor(model, tree, x);

julia&gt; y
1-element Vector{VariableRef}:
 moai_AffineCombination[1]

julia&gt; MathOptAI.build_predictor(tree)
AffineCombination
├ 1.0 * BinaryDecisionTree{Float64,Float64} [leaves=3, depth=2]
├ 1.0 * BinaryDecisionTree{Float64,Float64} [leaves=3, depth=2]
├ 1.0 * BinaryDecisionTree{Float64,Float64} [leaves=3, depth=2]
└ 1.0 * [2.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/ext/MathOptAIEvoTreesExt.jl#L13-L55">source</a></section></details></article><h2 id="output_size"><a class="docs-heading-anchor" href="#output_size"><code>output_size</code></a><a id="output_size-1"></a><a class="docs-heading-anchor-permalink" href="#output_size" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.output_size"><a class="docstring-binding" href="#MathOptAI.output_size"><code>MathOptAI.output_size</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">output_size(predictor::AbstractPredictor, input_size::Nothing)
output_size(predictor::AbstractPredictor, input_size::NTuple{N,Int}) where {N}</code></pre><p>Return the output size of <code>predictor</code> with an input with shape <code>input_size</code>.</p><p>If <code>input_size === nothing</code>, no information about the input is known. This function returns an <code>NTuple{N,Int}</code> if a static output size based on the predictor, otherwise returns <code>nothing</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using MathOptAI

julia&gt; output_size(ReLU(), nothing)

julia&gt; output_size(ReLU(), (2,))
(2,)

julia&gt; output_size(MaxPool2d((3, 3); input_size = (6, 9, 1)), (6, 9, 1))
(2, 3, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/MathOptAI.jl#L333-L356">source</a></section></details></article><h2 id="Affine"><a class="docs-heading-anchor" href="#Affine"><code>Affine</code></a><a id="Affine-1"></a><a class="docs-heading-anchor-permalink" href="#Affine" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.Affine"><a class="docstring-binding" href="#MathOptAI.Affine"><code>MathOptAI.Affine</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Affine(
    A::Matrix{T},
    b::Vector{T} = zeros(T, size(A, 1)),
) where {T} &lt;: AbstractPredictor</code></pre><p>An <a href="#AbstractPredictor"><code>AbstractPredictor</code></a> that represents the relationship:</p><p class="math-container">\[y = A x + b\]</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI

julia&gt; model = Model();

julia&gt; @variable(model, 0 &lt;= x[i in 1:2] &lt;= i);

julia&gt; f = MathOptAI.Affine([2.0 3.0], [4.0])
Affine(A, b) [input: 2, output: 1]

julia&gt; y, formulation = MathOptAI.add_predictor(model, f, x);

julia&gt; y
1-element Vector{VariableRef}:
 moai_Affine[1]

julia&gt; formulation
Affine(A, b) [input: 2, output: 1]
├ variables [1]
│ └ moai_Affine[1]
└ constraints [3]
  ├ moai_Affine[1] ≥ 4
  ├ moai_Affine[1] ≤ 12
  └ 2 x[1] + 3 x[2] - moai_Affine[1] = -4

julia&gt; y, formulation =
           MathOptAI.add_predictor(model, MathOptAI.ReducedSpace(f), x);

julia&gt; y
1-element Vector{AffExpr}:
 2 x[1] + 3 x[2] + 4

julia&gt; formulation
ReducedSpace(Affine(A, b) [input: 2, output: 1])
├ variables [0]
└ constraints [0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/predictors/Affine.jl#L7-L57">source</a></section></details></article><h2 id="AffineCombination"><a class="docs-heading-anchor" href="#AffineCombination"><code>AffineCombination</code></a><a id="AffineCombination-1"></a><a class="docs-heading-anchor-permalink" href="#AffineCombination" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.AffineCombination"><a class="docstring-binding" href="#MathOptAI.AffineCombination"><code>MathOptAI.AffineCombination</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AffineCombination(
    predictors::Vector{&lt;:AbstractPredictor},
    weights::Vector{Float64},
    constant::Vector{Float64},
)</code></pre><p>An <a href="#AbstractPredictor"><code>AbstractPredictor</code></a> that represents the linear combination of other predictors.</p><p>The main purpose of this predictor is to model random forests and gradient boosted trees.</p><ul><li>A random forest is the mean a set of <a href="#BinaryDecisionTree"><code>BinaryDecisionTree</code></a></li><li>A gradient boosted tree is the sum of a set of <a href="#BinaryDecisionTree"><code>BinaryDecisionTree</code></a></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI

julia&gt; rhs = MathOptAI.BinaryDecisionTree(1, 1.0, 0, 1)
BinaryDecisionTree{Float64,Int64} [leaves=2, depth=2]

julia&gt; lhs = MathOptAI.BinaryDecisionTree(1, -0.1, -1, 0)
BinaryDecisionTree{Float64,Int64} [leaves=2, depth=2]

julia&gt; tree_1 = MathOptAI.BinaryDecisionTree(1, 0.0, -1, rhs);

julia&gt; tree_2 = MathOptAI.BinaryDecisionTree(1, 0.9, lhs, 1);

julia&gt; random_forest = MathOptAI.AffineCombination(
           [tree_1, tree_2],
           [0.5, 0.5],
           [0.0],
       )
AffineCombination
├ 0.5 * BinaryDecisionTree{Float64,Int64} [leaves=3, depth=2]
├ 0.5 * BinaryDecisionTree{Float64,Int64} [leaves=3, depth=2]
└ 1.0 * [0.0]

julia&gt; model = Model();

julia&gt; @variable(model, -3 &lt;= x[1:1] &lt;= 5);

julia&gt; y, formulation = MathOptAI.add_predictor(model, random_forest, x);

julia&gt; y
1-element Vector{VariableRef}:
 moai_AffineCombination[1]

julia&gt; formulation
AffineCombination
├ 0.5 * BinaryDecisionTree{Float64,Int64} [leaves=3, depth=2]
├ 0.5 * BinaryDecisionTree{Float64,Int64} [leaves=3, depth=2]
└ 1.0 * [0.0]
├ variables [1]
│ └ moai_AffineCombination[1]
└ constraints [1]
  └ 0.5 moai_BinaryDecisionTree_value[1] + 0.5 moai_BinaryDecisionTree_value[1] - moai_AffineCombination[1] = 0
BinaryDecisionTree{Float64,Int64} [leaves=3, depth=2]
├ variables [4]
│ ├ moai_BinaryDecisionTree_value[1]
│ ├ moai_BinaryDecisionTree_z[1]
│ ├ moai_BinaryDecisionTree_z[2]
│ └ moai_BinaryDecisionTree_z[3]
└ constraints [7]
  ├ moai_BinaryDecisionTree_z[1] + moai_BinaryDecisionTree_z[2] + moai_BinaryDecisionTree_z[3] = 1
  ├ moai_BinaryDecisionTree_z[1] --&gt; {x[1] ≤ -1.0e-6}
  ├ moai_BinaryDecisionTree_z[2] --&gt; {x[1] ≥ 0}
  ├ moai_BinaryDecisionTree_z[2] --&gt; {x[1] ≤ 0.999999}
  ├ moai_BinaryDecisionTree_z[3] --&gt; {x[1] ≥ 0}
  ├ moai_BinaryDecisionTree_z[3] --&gt; {x[1] ≥ 1}
  └ moai_BinaryDecisionTree_z[1] - moai_BinaryDecisionTree_z[3] + moai_BinaryDecisionTree_value[1] = 0
BinaryDecisionTree{Float64,Int64} [leaves=3, depth=2]
├ variables [4]
│ ├ moai_BinaryDecisionTree_value[1]
│ ├ moai_BinaryDecisionTree_z[1]
│ ├ moai_BinaryDecisionTree_z[2]
│ └ moai_BinaryDecisionTree_z[3]
└ constraints [7]
  ├ moai_BinaryDecisionTree_z[1] + moai_BinaryDecisionTree_z[2] + moai_BinaryDecisionTree_z[3] = 1
  ├ moai_BinaryDecisionTree_z[1] --&gt; {x[1] ≤ 0.899999}
  ├ moai_BinaryDecisionTree_z[1] --&gt; {x[1] ≤ -0.100001}
  ├ moai_BinaryDecisionTree_z[2] --&gt; {x[1] ≤ 0.899999}
  ├ moai_BinaryDecisionTree_z[2] --&gt; {x[1] ≥ -0.1}
  ├ moai_BinaryDecisionTree_z[3] --&gt; {x[1] ≥ 0.9}
  └ moai_BinaryDecisionTree_z[1] - moai_BinaryDecisionTree_z[3] + moai_BinaryDecisionTree_value[1] = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/predictors/AffineCombination.jl#L7-L96">source</a></section></details></article><h2 id="AvgPool2d"><a class="docs-heading-anchor" href="#AvgPool2d"><code>AvgPool2d</code></a><a id="AvgPool2d-1"></a><a class="docs-heading-anchor-permalink" href="#AvgPool2d" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.AvgPool2d"><a class="docstring-binding" href="#MathOptAI.AvgPool2d"><code>MathOptAI.AvgPool2d</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AvgPool2d(
    kernel_size::Tuple{Int,Int};
    input_size::Tuple{Int,Int,Int},
    stride::Tuple{Int,Int} = (1, 1),
    padding::Tuple{Int,Int} = (0, 0),
) &lt;: AbstractPredictor</code></pre><p>An <a href="#AbstractPredictor"><code>AbstractPredictor</code></a> that represents a mean pooling layer.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI

julia&gt; model = Model();

julia&gt; @variable(model, x[h in 1:2, w in 1:4])
2×4 Matrix{VariableRef}:
 x[1,1]  x[1,2]  x[1,3]  x[1,4]
 x[2,1]  x[2,2]  x[2,3]  x[2,4]

julia&gt; predictor = MathOptAI.AvgPool2d((2, 2); input_size = (2, 4, 1))
AvgPool2d((2, 4, 1), (2, 2), (2, 2), (0, 0))

julia&gt; y, formulation = MathOptAI.add_predictor(model, predictor, vec(x));

julia&gt; y
2-element Vector{VariableRef}:
 moai_AvgPool2d[1]
 moai_AvgPool2d[2]

julia&gt; formulation
AvgPool2d((2, 4, 1), (2, 2), (2, 2), (0, 0))
├ variables [2]
│ ├ moai_AvgPool2d[1]
│ └ moai_AvgPool2d[2]
└ constraints [2]
  ├ -0.25 x[1,1] - 0.25 x[2,1] - 0.25 x[1,2] - 0.25 x[2,2] + moai_AvgPool2d[1] = 0
  └ -0.25 x[1,3] - 0.25 x[2,3] - 0.25 x[1,4] - 0.25 x[2,4] + moai_AvgPool2d[2] = 0

julia&gt; y, formulation =
           MathOptAI.add_predictor(model, predictor, vec(x); reduced_space = true);

julia&gt; y
2-element Vector{AffExpr}:
 0.25 x[1,1] + 0.25 x[1,2] + 0.25 x[2,1] + 0.25 x[2,2]
 0.25 x[1,3] + 0.25 x[1,4] + 0.25 x[2,3] + 0.25 x[2,4]

julia&gt; formulation
ReducedSpace(AvgPool2d((2, 4, 1), (2, 2), (2, 2), (0, 0)))
├ variables [0]
└ constraints [0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/predictors/AvgPool2d.jl#L7-L61">source</a></section></details></article><h2 id="BinaryDecisionTree"><a class="docs-heading-anchor" href="#BinaryDecisionTree"><code>BinaryDecisionTree</code></a><a id="BinaryDecisionTree-1"></a><a class="docs-heading-anchor-permalink" href="#BinaryDecisionTree" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.BinaryDecisionTree"><a class="docstring-binding" href="#MathOptAI.BinaryDecisionTree"><code>MathOptAI.BinaryDecisionTree</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BinaryDecisionTree{K,V}(
    feat_id::Int,
    feat_value::K,
    lhs::Union{V,BinaryDecisionTree{K,V}},
    rhs::Union{V,BinaryDecisionTree{K,V}},
    atol::Float64 = 1e-6,
)</code></pre><p>An <a href="#AbstractPredictor"><code>AbstractPredictor</code></a> that represents a binary decision tree.</p><ul><li>If <code>x[feat_id] &lt;= feat_value - atol</code>, then return <code>lhs</code></li><li>If <code>x[feat_id] &gt;= feat_value</code>, then return <code>rhs</code></li></ul><p><strong>Example</strong></p><p>To represent the tree <code>x[1] &lt;= 0.0 ? -1 : (x[1] &lt;= 1.0 ? 0 : 1)</code>, do:</p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI

julia&gt; model = Model();

julia&gt; @variable(model, x[1:1]);

julia&gt; f = MathOptAI.BinaryDecisionTree{Float64,Int}(
           1,
           0.0,
           -1,
           MathOptAI.BinaryDecisionTree{Float64,Int}(1, 1.0, 0, 1),
       )
BinaryDecisionTree{Float64,Int64} [leaves=3, depth=2]

julia&gt; y, formulation = MathOptAI.add_predictor(model, f, x);

julia&gt; y
1-element Vector{VariableRef}:
 moai_BinaryDecisionTree_value[1]

julia&gt; formulation
BinaryDecisionTree{Float64,Int64} [leaves=3, depth=2]
├ variables [4]
│ ├ moai_BinaryDecisionTree_value[1]
│ ├ moai_BinaryDecisionTree_z[1]
│ ├ moai_BinaryDecisionTree_z[2]
│ └ moai_BinaryDecisionTree_z[3]
└ constraints [7]
  ├ moai_BinaryDecisionTree_z[1] + moai_BinaryDecisionTree_z[2] + moai_BinaryDecisionTree_z[3] = 1
  ├ moai_BinaryDecisionTree_z[1] --&gt; {x[1] ≤ -1.0e-6}
  ├ moai_BinaryDecisionTree_z[2] --&gt; {x[1] ≥ 0}
  ├ moai_BinaryDecisionTree_z[2] --&gt; {x[1] ≤ 0.999999}
  ├ moai_BinaryDecisionTree_z[3] --&gt; {x[1] ≥ 0}
  ├ moai_BinaryDecisionTree_z[3] --&gt; {x[1] ≥ 1}
  └ moai_BinaryDecisionTree_z[1] - moai_BinaryDecisionTree_z[3] + moai_BinaryDecisionTree_value[1] = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/predictors/BinaryDecisionTree.jl#L7-L62">source</a></section></details></article><h2 id="Conv2d"><a class="docs-heading-anchor" href="#Conv2d"><code>Conv2d</code></a><a id="Conv2d-1"></a><a class="docs-heading-anchor-permalink" href="#Conv2d" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.Conv2d"><a class="docstring-binding" href="#MathOptAI.Conv2d"><code>MathOptAI.Conv2d</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Conv2d(
    weight::Array{T,4},
    bias::Vector{T};
    input_size::Tuple{Int,Int,Int},
    stride::Tuple{Int,Int} = (1, 1),
    padding::Tuple{Int,Int} = (0, 0),
) where {T} &lt;: AbstractPredictor</code></pre><p>An <a href="#AbstractPredictor"><code>AbstractPredictor</code></a> that represents a mean pooling layer a 2-dimensional convolutional layer.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI

julia&gt; model = Model();

julia&gt; @variable(model, x[h in 1:2, w in 1:3])
2×3 Matrix{VariableRef}:
 x[1,1]  x[1,2]  x[1,3]
 x[2,1]  x[2,2]  x[2,3]

julia&gt; weight = reshape(collect(1.0:8.0), 2, 2, 1, 2);

julia&gt; bias = [-1.0, -2.0];

julia&gt; predictor = MathOptAI.Conv2d(weight, bias; input_size = (2, 3, 1))
Conv2d{Float64}((2, 3, 1), [1.0 3.0; 2.0 4.0;;;; 5.0 7.0; 6.0 8.0], [-1.0, -2.0], (1, 1), (0, 0))

julia&gt; y, formulation = MathOptAI.add_predictor(model, predictor, vec(x));

julia&gt; y
4-element Vector{VariableRef}:
 moai_Conv2d[1]
 moai_Conv2d[2]
 moai_Conv2d[3]
 moai_Conv2d[4]

julia&gt; formulation
Conv2d{Float64}((2, 3, 1), [1.0 3.0; 2.0 4.0;;;; 5.0 7.0; 6.0 8.0], [-1.0, -2.0], (1, 1), (0, 0))
├ variables [4]
│ ├ moai_Conv2d[1]
│ ├ moai_Conv2d[2]
│ ├ moai_Conv2d[3]
│ └ moai_Conv2d[4]
└ constraints [4]
  ├ -4 x[1,1] - 3 x[2,1] - 2 x[1,2] - x[2,2] + moai_Conv2d[1] = -1
  ├ -4 x[1,2] - 3 x[2,2] - 2 x[1,3] - x[2,3] + moai_Conv2d[2] = -1
  ├ -8 x[1,1] - 7 x[2,1] - 6 x[1,2] - 5 x[2,2] + moai_Conv2d[3] = -2
  └ -8 x[1,2] - 7 x[2,2] - 6 x[1,3] - 5 x[2,3] + moai_Conv2d[4] = -2

julia&gt; y, formulation =
           MathOptAI.add_predictor(model, predictor, vec(x); reduced_space = true);

julia&gt; y
4-element Vector{AffExpr}:
 4 x[1,1] + 2 x[1,2] + 3 x[2,1] + x[2,2] - 1
 4 x[1,2] + 2 x[1,3] + 3 x[2,2] + x[2,3] - 1
 8 x[1,1] + 6 x[1,2] + 7 x[2,1] + 5 x[2,2] - 2
 8 x[1,2] + 6 x[1,3] + 7 x[2,2] + 5 x[2,3] - 2

julia&gt; formulation
ReducedSpace(Conv2d{Float64}((2, 3, 1), [1.0 3.0; 2.0 4.0;;;; 5.0 7.0; 6.0 8.0], [-1.0, -2.0], (1, 1), (0, 0)))
├ variables [0]
└ constraints [0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/predictors/Conv2d.jl#L7-L75">source</a></section></details></article><h2 id="GCNConv"><a class="docs-heading-anchor" href="#GCNConv"><code>GCNConv</code></a><a id="GCNConv-1"></a><a class="docs-heading-anchor-permalink" href="#GCNConv" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.GCNConv"><a class="docstring-binding" href="#MathOptAI.GCNConv"><code>MathOptAI.GCNConv</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GCNConv(;
    weights::Matrix{T},
    bias::Vector{T},
    edge_index::Vector{Pair{Int,Int}},
)</code></pre><p>An <a href="#AbstractPredictor"><code>AbstractPredictor</code></a> that represents a graph convolutional network operator:</p><p class="math-container">\[Y = D^{-1/2} A D^{-1/2} X W + b\]</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI

julia&gt; model = Model();

julia&gt; @variable(model, x[1:3, 1:2]);

julia&gt; f = MathOptAI.GCNConv(;
           weights = [1.0; 2.0;;],
           bias = [7.0],
           edge_index = [1 =&gt; 2, 2 =&gt; 1, 2 =&gt; 3, 3 =&gt; 2],
       );

julia&gt; y, formulation = MathOptAI.add_predictor(model, f, vec(x));

julia&gt; y
3-element Vector{VariableRef}:
 moai_GCNConv[1]
 moai_GCNConv[2]
 moai_GCNConv[3]

julia&gt; formulation
GCNConv{Float64}([1.0; 2.0;;], [7.0], [0.4999999999999999 0.40824829046386296 0.0; 0.40824829046386296 0.33333333333333337 0.40824829046386296; 0.0 0.40824829046386296 0.4999999999999999])
├ variables [3]
│ ├ moai_GCNConv[1]
│ ├ moai_GCNConv[2]
│ └ moai_GCNConv[3]
└ constraints [3]
  ├ -0.4999999999999999 x[1,1] - 0.40824829046386296 x[2,1] - x[1,2] - 0.8164965809277259 x[2,2] + moai_GCNConv[1] = 7
  ├ -0.40824829046386296 x[1,1] - 0.33333333333333337 x[2,1] - 0.40824829046386296 x[3,1] - 0.8164965809277259 x[1,2] - 0.6666666666666667 x[2,2] - 0.8164965809277259 x[3,2] + moai_GCNConv[2] = 7
  └ -0.40824829046386296 x[2,1] - 0.4999999999999999 x[3,1] - 0.8164965809277259 x[2,2] - x[3,2] + moai_GCNConv[3] = 7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/predictors/GCNConv.jl#L7-L54">source</a></section></details></article><h2 id="GELU"><a class="docs-heading-anchor" href="#GELU"><code>GELU</code></a><a id="GELU-1"></a><a class="docs-heading-anchor-permalink" href="#GELU" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.GELU"><a class="docstring-binding" href="#MathOptAI.GELU"><code>MathOptAI.GELU</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GeLU() &lt;: AbstractPredictor</code></pre><p>An <a href="#AbstractPredictor"><code>AbstractPredictor</code></a> representing the Gaussian Error Linear Units function:</p><p class="math-container">\[y \approx x * (1 + \tanh(\sqrt(2 / \pi) * (x + 0.044715 x^3))) / 2\]</p><p>as a smooth nonlinear constraint.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI

julia&gt; model = Model();

julia&gt; @variable(model, -1 &lt;= x[i in 1:2] &lt;= i);

julia&gt; f = MathOptAI.GELU()
GELU()

julia&gt; y, formulation = MathOptAI.add_predictor(model, f, x);

julia&gt; y
2-element Vector{VariableRef}:
 moai_GELU[1]
 moai_GELU[2]

julia&gt; formulation
GELU()
├ variables [2]
│ ├ moai_GELU[1]
│ └ moai_GELU[2]
└ constraints [6]
  ├ moai_GELU[1] ≥ -0.17
  ├ moai_GELU[1] ≤ 0.8411919906082768
  ├ moai_GELU[1] - ((0.5 x[1]) * (1 + tanh(0.7978845608028654 * (x[1] + (0.044715 * (x[1] ^ 3)))))) = 0
  ├ moai_GELU[2] ≥ -0.17
  ├ moai_GELU[2] ≤ 1.954597694087775
  └ moai_GELU[2] - ((0.5 x[2]) * (1 + tanh(0.7978845608028654 * (x[2] + (0.044715 * (x[2] ^ 3)))))) = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/predictors/GELU.jl#L7-L49">source</a></section></details></article><h2 id="GrayBox"><a class="docs-heading-anchor" href="#GrayBox"><code>GrayBox</code></a><a id="GrayBox-1"></a><a class="docs-heading-anchor-permalink" href="#GrayBox" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.GrayBox"><a class="docstring-binding" href="#MathOptAI.GrayBox"><code>MathOptAI.GrayBox</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs"> GrayBox(
    predictor::P;
    device::String = &quot;cpu&quot;,
    hessian::Bool = true,
) where {P}</code></pre><p>An <a href="#AbstractPredictor"><code>AbstractPredictor</code></a> that represents the relationship:</p><p class="math-container">\[y = f(x)\]</p><p>as a vector nonlinear operator.</p><p>This predictor should not be used directly; it is intended to be used by extensions like Flux and PyTorch.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI, Flux

julia&gt; chain = Flux.Chain(Flux.Dense(1 =&gt; 16, Flux.relu), Flux.Dense(16 =&gt; 1));

julia&gt; model = Model();

julia&gt; @variable(model, x[1:1]);

julia&gt; y, _ = MathOptAI.add_predictor(model, chain, x; gray_box = true);

julia&gt; y
1-element Vector{VariableRef}:
 moai_Flux[1]

julia&gt; print(model)
Feasibility
Subject to
 [x[1], moai_Flux[1]] ∈ VectorNonlinearOracle{Float64}(;
     dimension = 2,
     l = [0.0],
     u = [0.0],
     ...,
 )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/predictors/GrayBox.jl#L7-L50">source</a></section></details></article><h2 id="LayerNorm"><a class="docs-heading-anchor" href="#LayerNorm"><code>LayerNorm</code></a><a id="LayerNorm-1"></a><a class="docs-heading-anchor-permalink" href="#LayerNorm" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.LayerNorm"><a class="docstring-binding" href="#MathOptAI.LayerNorm"><code>MathOptAI.LayerNorm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LayerNorm(
    shape::NTuple{N,Int};
    input_size::Tuple{Int,Int,Int},
    eps::Float64 = 1e-5,
) where {N}</code></pre><p>An <a href="#AbstractPredictor"><code>AbstractPredictor</code></a> that represents the relationship:</p><p class="math-container">\[y = \frac{x - E[x]}{\sqrt{Var(x) + \eps}}\]</p><p>where <code>E</code> and <code>Var</code> are computed over the first <code>shape</code> dimensions of <code>x</code>.</p><p>!!! Note     This layer does <strong>not</strong> implement the affine scaling seen in some layers.     Apply <a href="#Scale"><code>Scale</code></a> to the outputs of this predictor instead.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI

julia&gt; model = Model();

julia&gt; @variable(model, x[1:2, 1:3]);

julia&gt; f = MathOptAI.LayerNorm(
           (2,);
           eps = 0.0,
           input_size = (2, 3, 1),
           weight = [1.0, 2.0],
           bias = [0.5, 0.6],
       )
LayerNorm{Float64, 1}((2, 3, 1), (2,), 0.0, [1.0, 2.0], [0.5, 0.6])

julia&gt; y, formulation = MathOptAI.add_predictor(model, f, vec(x));

julia&gt; y
6-element Vector{VariableRef}:
 moai_LayerNorm[1]
 moai_LayerNorm[2]
 moai_LayerNorm[3]
 moai_LayerNorm[4]
 moai_LayerNorm[5]
 moai_LayerNorm[6]

julia&gt; formulation
LayerNorm{Float64, 1}((2, 3, 1), (2,), 0.0, [1.0, 2.0], [0.5, 0.6])
├ variables [3]
│ ├ VariableRef[moai_LayerNorm_μ[1], moai_LayerNorm_μ[2], moai_LayerNorm_μ[3]]
│ ├ VariableRef[moai_LayerNorm_σ[1], moai_LayerNorm_σ[2], moai_LayerNorm_σ[3]]
│ └ VariableRef[moai_LayerNorm[1], moai_LayerNorm[2], moai_LayerNorm[3], moai_LayerNorm[4], moai_LayerNorm[5], moai_LayerNorm[6]]
└ constraints [15]
  ├ moai_LayerNorm_σ[1] ≥ 0
  ├ moai_LayerNorm_σ[2] ≥ 0
  ├ moai_LayerNorm_σ[3] ≥ 0
  ├ -x[1,1] - x[2,1] + 2 moai_LayerNorm_μ[1] = 0
  ├ -0.5 x[1,1]² + moai_LayerNorm_μ[1]*x[1,1] - 0.5 x[2,1]² + moai_LayerNorm_μ[1]*x[2,1] - moai_LayerNorm_μ[1]² + moai_LayerNorm_σ[1]² = 0
  ├ moai_LayerNorm_σ[1]*moai_LayerNorm[1] - x[1,1] + moai_LayerNorm_μ[1] - 0.5 moai_LayerNorm_σ[1] = 0
  ├ moai_LayerNorm_σ[1]*moai_LayerNorm[2] - 2 x[2,1] + 2 moai_LayerNorm_μ[1] - 0.6 moai_LayerNorm_σ[1] = 0
  ├ -x[1,2] - x[2,2] + 2 moai_LayerNorm_μ[2] = 0
  ├ -0.5 x[1,2]² + moai_LayerNorm_μ[2]*x[1,2] - 0.5 x[2,2]² + moai_LayerNorm_μ[2]*x[2,2] - moai_LayerNorm_μ[2]² + moai_LayerNorm_σ[2]² = 0
  ├ moai_LayerNorm_σ[2]*moai_LayerNorm[3] - x[1,2] + moai_LayerNorm_μ[2] - 0.5 moai_LayerNorm_σ[2] = 0
  ├ moai_LayerNorm_σ[2]*moai_LayerNorm[4] - 2 x[2,2] + 2 moai_LayerNorm_μ[2] - 0.6 moai_LayerNorm_σ[2] = 0
  ├ -x[1,3] - x[2,3] + 2 moai_LayerNorm_μ[3] = 0
  ├ -0.5 x[1,3]² + moai_LayerNorm_μ[3]*x[1,3] - 0.5 x[2,3]² + moai_LayerNorm_μ[3]*x[2,3] - moai_LayerNorm_μ[3]² + moai_LayerNorm_σ[3]² = 0
  ├ moai_LayerNorm_σ[3]*moai_LayerNorm[5] - x[1,3] + moai_LayerNorm_μ[3] - 0.5 moai_LayerNorm_σ[3] = 0
  └ moai_LayerNorm_σ[3]*moai_LayerNorm[6] - 2 x[2,3] + 2 moai_LayerNorm_μ[3] - 0.6 moai_LayerNorm_σ[3] = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/predictors/LayerNorm.jl#L7-L76">source</a></section></details></article><h2 id="LeakyReLU"><a class="docs-heading-anchor" href="#LeakyReLU"><code>LeakyReLU</code></a><a id="LeakyReLU-1"></a><a class="docs-heading-anchor-permalink" href="#LeakyReLU" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.LeakyReLU"><a class="docstring-binding" href="#MathOptAI.LeakyReLU"><code>MathOptAI.LeakyReLU</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LeakyReLU(;
    negative_slope::Float64,
    relu::AbstractPredictor = ReLU(),
) &lt;: AbstractPredictor</code></pre><p>An <a href="#AbstractPredictor"><code>AbstractPredictor</code></a> that represents the relationship:</p><p class="math-container">\[y = \max\{0, x\} + \eta \cdot \min\{0, x\}\]</p><p>or equivalently:</p><p class="math-container">\[y = \eta \cdot x + (1 - \eta) \cdot \max\{0, x\}\]</p><p>where <code>negative_slope</code> is <span>$\eta$</span> and <code>relu</code> is used to represent <span>$\max\{0, x\}$</span>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI

julia&gt; model = Model();

julia&gt; @variable(model, -1 &lt;= x[i in 1:2] &lt;= i);

julia&gt; f = MathOptAI.LeakyReLU(; negative_slope = 0.01)
LeakyReLU{ReLU}(0.01, ReLU())

julia&gt; y, formulation = MathOptAI.add_predictor(model, f, x);

julia&gt; y
2-element Vector{VariableRef}:
 moai_LeakyReLU[1]
 moai_LeakyReLU[2]

julia&gt; formulation
LeakyReLU{ReLU}(0.01, ReLU())
├ variables [4]
│ ├ moai_ReLU[1]
│ ├ moai_ReLU[2]
│ ├ moai_LeakyReLU[1]
│ └ moai_LeakyReLU[2]
└ constraints [8]
  ├ moai_ReLU[1] ≥ 0
  ├ moai_ReLU[1] ≤ 1
  ├ moai_ReLU[1] - max(0, x[1]) = 0
  ├ moai_ReLU[2] ≥ 0
  ├ moai_ReLU[2] ≤ 2
  ├ moai_ReLU[2] - max(0, x[2]) = 0
  ├ -0.01 x[1] + moai_LeakyReLU[1] - 0.99 moai_ReLU[1] = 0
  └ -0.01 x[2] + moai_LeakyReLU[2] - 0.99 moai_ReLU[2] = 0

julia&gt; y, formulation =
           MathOptAI.add_predictor(model, MathOptAI.ReducedSpace(f), x);

julia&gt; y
2-element Vector{NonlinearExpr}:
 (0.01 x[1]) + (0.99 * max(0, x[1]))
 (0.01 x[2]) + (0.99 * max(0, x[2]))

julia&gt; formulation
ReducedSpace(LeakyReLU{ReLU}(0.01, ReLU()))
├ variables [0]
└ constraints [0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/predictors/LeakyReLU.jl#L7-L73">source</a></section></details></article><h2 id="MaxPool2d"><a class="docs-heading-anchor" href="#MaxPool2d"><code>MaxPool2d</code></a><a id="MaxPool2d-1"></a><a class="docs-heading-anchor-permalink" href="#MaxPool2d" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.MaxPool2d"><a class="docstring-binding" href="#MathOptAI.MaxPool2d"><code>MathOptAI.MaxPool2d</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MaxPool2d(
    kernel_size::Tuple{Int,Int};
    input_size::Tuple{Int,Int,Int},
    stride::Tuple{Int,Int} = (1, 1),
    padding::Tuple{Int,Int} = (0, 0),
) &lt;: AbstractPredictor</code></pre><p>An <a href="#AbstractPredictor"><code>AbstractPredictor</code></a> that represents a two-dimensinal max pooling layer.</p><p>The <code>max</code> function is implemented as a non-smooth nonlinear constraint.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI

julia&gt; model = Model();

julia&gt; @variable(model, x[h in 1:2, w in 1:4])
2×4 Matrix{VariableRef}:
 x[1,1]  x[1,2]  x[1,3]  x[1,4]
 x[2,1]  x[2,2]  x[2,3]  x[2,4]

julia&gt; predictor = MathOptAI.MaxPool2d((2, 2); input_size = (2, 4, 1))
MaxPool2d((2, 4, 1), (2, 2), (2, 2), (0, 0))

julia&gt; y, formulation = MathOptAI.add_predictor(model, predictor, vec(x));

julia&gt; y
2-element Vector{VariableRef}:
 moai_MaxPool2d[1]
 moai_MaxPool2d[2]

julia&gt; formulation
MaxPool2d((2, 4, 1), (2, 2), (2, 2), (0, 0))
├ variables [2]
│ ├ moai_MaxPool2d[1]
│ └ moai_MaxPool2d[2]
└ constraints [2]
  ├ moai_MaxPool2d[1] - max(max(max(x[1,1], x[2,1]), x[1,2]), x[2,2]) = 0
  └ moai_MaxPool2d[2] - max(max(max(x[1,3], x[2,3]), x[1,4]), x[2,4]) = 0

julia&gt; y, formulation =
           MathOptAI.add_predictor(model, predictor, vec(x); reduced_space = true);

julia&gt; y
2-element Vector{NonlinearExpr}:
 max(max(max(x[1,1], x[2,1]), x[1,2]), x[2,2])
 max(max(max(x[1,3], x[2,3]), x[1,4]), x[2,4])

julia&gt; formulation
ReducedSpace(MaxPool2d((2, 4, 1), (2, 2), (2, 2), (0, 0)))
├ variables [0]
└ constraints [0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/predictors/MaxPool2d.jl#L7-L64">source</a></section></details></article><h2 id="MaxPool2dBigM"><a class="docs-heading-anchor" href="#MaxPool2dBigM"><code>MaxPool2dBigM</code></a><a id="MaxPool2dBigM-1"></a><a class="docs-heading-anchor-permalink" href="#MaxPool2dBigM" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.MaxPool2dBigM"><a class="docstring-binding" href="#MathOptAI.MaxPool2dBigM"><code>MathOptAI.MaxPool2dBigM</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MaxPool2dBigM(
    kernel_size::Tuple{Int,Int};
    M::Float64,
    input_size::Tuple{Int,Int,Int},
    stride::Tuple{Int,Int} = kernel_size,
    padding::Tuple{Int,Int} = (0, 0),
) &lt;: AbstractPredictor</code></pre><p>An <a href="#AbstractPredictor"><code>AbstractPredictor</code></a> that represents a two-dimensinal max pooling layer.</p><p>The <code>max</code> function is implemented as a big-M mixed-integer linear program.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI

julia&gt; model = Model();

julia&gt; @variable(model, x[h in 1:2, w in 1:4])
2×4 Matrix{VariableRef}:
 x[1,1]  x[1,2]  x[1,3]  x[1,4]
 x[2,1]  x[2,2]  x[2,3]  x[2,4]

julia&gt; predictor =
           MathOptAI.MaxPool2dBigM((2, 2); input_size = (2, 4, 1), M = 100.0)
MaxPool2dBigM((2, 4, 1), (2, 2), (2, 2), (0, 0), 100.0)

julia&gt; y, formulation = MathOptAI.add_predictor(model, predictor, vec(x));

julia&gt; y
2-element Vector{VariableRef}:
 moai_MaxPool2d[1]
 moai_MaxPool2d[2]

julia&gt; formulation
MaxPool2dBigM((2, 4, 1), (2, 2), (2, 2), (0, 0), 100.0)
├ variables [10]
│ ├ moai_MaxPool2d[1]
│ ├ moai_MaxPool2d[2]
│ ├ moai_z[h=1,w=1,c=1][1]
│ ├ moai_z[h=1,w=1,c=1][2]
│ ├ moai_z[h=1,w=1,c=1][3]
│ ├ moai_z[h=1,w=1,c=1][4]
│ ├ moai_z[h=1,w=2,c=1][1]
│ ├ moai_z[h=1,w=2,c=1][2]
│ ├ moai_z[h=1,w=2,c=1][3]
│ └ moai_z[h=1,w=2,c=1][4]
└ constraints [18]
  ├ -x[1,1] + moai_MaxPool2d[1] ≥ 0
  ├ -x[1,1] + moai_MaxPool2d[1] - 100 moai_z[h=1,w=1,c=1][1] ≤ 0
  ├ -x[1,2] + moai_MaxPool2d[1] ≥ 0
  ├ -x[1,2] + moai_MaxPool2d[1] - 100 moai_z[h=1,w=1,c=1][3] ≤ 0
  ├ -x[2,1] + moai_MaxPool2d[1] ≥ 0
  ├ -x[2,1] + moai_MaxPool2d[1] - 100 moai_z[h=1,w=1,c=1][2] ≤ 0
  ├ -x[2,2] + moai_MaxPool2d[1] ≥ 0
  ├ -x[2,2] + moai_MaxPool2d[1] - 100 moai_z[h=1,w=1,c=1][4] ≤ 0
  ├ moai_z[h=1,w=1,c=1][1] + moai_z[h=1,w=1,c=1][2] + moai_z[h=1,w=1,c=1][3] + moai_z[h=1,w=1,c=1][4] = 3
  ├ -x[1,3] + moai_MaxPool2d[2] ≥ 0
  ├ -x[1,3] + moai_MaxPool2d[2] - 100 moai_z[h=1,w=2,c=1][1] ≤ 0
  ├ -x[1,4] + moai_MaxPool2d[2] ≥ 0
  ├ -x[1,4] + moai_MaxPool2d[2] - 100 moai_z[h=1,w=2,c=1][3] ≤ 0
  ├ -x[2,3] + moai_MaxPool2d[2] ≥ 0
  ├ -x[2,3] + moai_MaxPool2d[2] - 100 moai_z[h=1,w=2,c=1][2] ≤ 0
  ├ -x[2,4] + moai_MaxPool2d[2] ≥ 0
  ├ -x[2,4] + moai_MaxPool2d[2] - 100 moai_z[h=1,w=2,c=1][4] ≤ 0
  └ moai_z[h=1,w=2,c=1][1] + moai_z[h=1,w=2,c=1][2] + moai_z[h=1,w=2,c=1][3] + moai_z[h=1,w=2,c=1][4] = 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/predictors/MaxPool2dBigM.jl#L7-L77">source</a></section></details></article><h2 id="Permutation"><a class="docs-heading-anchor" href="#Permutation"><code>Permutation</code></a><a id="Permutation-1"></a><a class="docs-heading-anchor-permalink" href="#Permutation" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.Permutation"><a class="docstring-binding" href="#MathOptAI.Permutation"><code>MathOptAI.Permutation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Permutation(p::Vector{Int}) &lt;: AbstractPredictor</code></pre><p>An <a href="#AbstractPredictor"><code>AbstractPredictor</code></a> that represents the relationship:</p><p class="math-container">\[y = x[p]\]</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI

julia&gt; model = Model();

julia&gt; @variable(model, x[1:2]);

julia&gt; f = MathOptAI.Permutation([2, 1])
Permutation([2, 1])

julia&gt; y, formulation =
           MathOptAI.add_predictor(model, f, x; reduced_space = true);

julia&gt; y
2-element Vector{VariableRef}:
 x[2]
 x[1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/predictors/Permutation.jl#L7-L35">source</a></section></details></article><h2 id="Pipeline"><a class="docs-heading-anchor" href="#Pipeline"><code>Pipeline</code></a><a id="Pipeline-1"></a><a class="docs-heading-anchor-permalink" href="#Pipeline" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.Pipeline"><a class="docstring-binding" href="#MathOptAI.Pipeline"><code>MathOptAI.Pipeline</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Pipeline(layers::Vector{AbstractPredictor}) &lt;: AbstractPredictor</code></pre><p>An <a href="#AbstractPredictor"><code>AbstractPredictor</code></a> that represents the relationship:</p><p class="math-container">\[y = (l_1 \circ \ldots \circ l_N)(x)\]</p><p>where <span>$l_i$</span> are a list of other <a href="#AbstractPredictor"><code>AbstractPredictor</code></a>s.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI

julia&gt; model = Model();

julia&gt; @variable(model, x[1:2]);

julia&gt; f = MathOptAI.Pipeline(
           MathOptAI.Affine([1.0 2.0], [0.0]),
           MathOptAI.ReLUQuadratic(),
       )
Pipeline with layers:
 * Affine(A, b) [input: 2, output: 1]
 * ReLUQuadratic(nothing)

julia&gt; y, formulation = MathOptAI.add_predictor(model, f, x);

julia&gt; y
1-element Vector{VariableRef}:
 moai_ReLU[1]

julia&gt; formulation
Affine(A, b) [input: 2, output: 1]
├ variables [1]
│ └ moai_Affine[1]
└ constraints [1]
  └ x[1] + 2 x[2] - moai_Affine[1] = 0
ReLUQuadratic(nothing)
├ variables [2]
│ ├ moai_ReLU[1]
│ └ moai_z[1]
└ constraints [4]
  ├ moai_ReLU[1] ≥ 0
  ├ moai_z[1] ≥ 0
  ├ moai_Affine[1] - moai_ReLU[1] + moai_z[1] = 0
  └ moai_ReLU[1]*moai_z[1] = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/predictors/Pipeline.jl#L7-L55">source</a></section></details></article><h2 id="PytorchModel"><a class="docs-heading-anchor" href="#PytorchModel"><code>PytorchModel</code></a><a id="PytorchModel-1"></a><a class="docs-heading-anchor-permalink" href="#PytorchModel" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.PytorchModel"><a class="docstring-binding" href="#MathOptAI.PytorchModel"><code>MathOptAI.PytorchModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PytorchModel(filename::String)</code></pre><p>A wrapper struct for loading a PyTorch model.</p><p>The only supported file extension is <code>.pt</code>, where the <code>.pt</code> file has been created using <code>torch.save(model, filename)</code>.</p><div class="admonition is-warning" id="Warning-bfafef02e41e51dc"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-bfafef02e41e51dc" title="Permalink"></a></header><div class="admonition-body"><p>To use <a href="#PytorchModel"><code>PytorchModel</code></a>, your code must load the <code>PythonCall</code> package:</p><pre><code class="language-julia hljs">import PythonCall</code></pre><p>See the <a href="../manual/PythonCall/#Python-integration">Python integration</a> section of the documentation for instructions on how to link Python to Julia.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using MathOptAI

julia&gt; using PythonCall  #  This line is important!

julia&gt; predictor = PytorchModel(&quot;model.pt&quot;);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/predictors/PytorchModel.jl#L7-L32">source</a></section></details></article><h2 id="Quantile"><a class="docs-heading-anchor" href="#Quantile"><code>Quantile</code></a><a id="Quantile-1"></a><a class="docs-heading-anchor-permalink" href="#Quantile" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.Quantile"><a class="docstring-binding" href="#MathOptAI.Quantile"><code>MathOptAI.Quantile</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Quantile{D}(distribution::D, quantiles::Vector{Float64}) where {D}</code></pre><p>An <a href="#AbstractPredictor"><code>AbstractPredictor</code></a> that represents the <code>quantiles</code> of <code>distribution</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, Distributions, MathOptAI

julia&gt; model = Model();

julia&gt; @variable(model, 1 &lt;= x &lt;= 2);

julia&gt; predictor = MathOptAI.Quantile([0.1, 0.9]) do x
           return Distributions.Normal(x, 3 - x)
       end
Quantile(_, [0.1, 0.9])

julia&gt; y, formulation = MathOptAI.add_predictor(model, predictor, [x]);

julia&gt; y
2-element Vector{VariableRef}:
 moai_quantile[1]
 moai_quantile[2]

julia&gt; formulation
Quantile(_, [0.1, 0.9])
├ variables [2]
│ ├ moai_quantile[1]
│ └ moai_quantile[2]
└ constraints [2]
  ├ moai_quantile[1] - op_quantile_0.1(x) = 0
  └ moai_quantile[2] - op_quantile_0.9(x) = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/predictors/Quantile.jl#L7-L42">source</a></section></details></article><h2 id="ReducedSpace"><a class="docs-heading-anchor" href="#ReducedSpace"><code>ReducedSpace</code></a><a id="ReducedSpace-1"></a><a class="docs-heading-anchor-permalink" href="#ReducedSpace" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.ReducedSpace"><a class="docstring-binding" href="#MathOptAI.ReducedSpace"><code>MathOptAI.ReducedSpace</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ReducedSpace(predictor::AbstractPredictor)</code></pre><p>A wrapper type for other predictors that implement a reduced-space formulation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI

julia&gt; model = Model();

julia&gt; @variable(model, x[1:2]);

julia&gt; predictor = MathOptAI.ReducedSpace(MathOptAI.ReLU());

julia&gt; y, formulation = MathOptAI.add_predictor(model, predictor, x);

julia&gt; y
2-element Vector{NonlinearExpr}:
 max(0, x[1])
 max(0, x[2])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/MathOptAI.jl#L283-L306">source</a></section></details></article><h2 id="ReLU"><a class="docs-heading-anchor" href="#ReLU"><code>ReLU</code></a><a id="ReLU-1"></a><a class="docs-heading-anchor-permalink" href="#ReLU" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.ReLU"><a class="docstring-binding" href="#MathOptAI.ReLU"><code>MathOptAI.ReLU</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ReLU() &lt;: AbstractPredictor</code></pre><p>An <a href="#AbstractPredictor"><code>AbstractPredictor</code></a> that represents the relationship:</p><p class="math-container">\[y = \max\{0, x\}\]</p><p>as a non-smooth nonlinear constraint.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI

julia&gt; model = Model();

julia&gt; @variable(model, -1 &lt;= x[i in 1:2] &lt;= i);

julia&gt; f = MathOptAI.ReLU()
ReLU()

julia&gt; y, formulation = MathOptAI.add_predictor(model, f, x);

julia&gt; y
2-element Vector{VariableRef}:
 moai_ReLU[1]
 moai_ReLU[2]

julia&gt; formulation
ReLU()
├ variables [2]
│ ├ moai_ReLU[1]
│ └ moai_ReLU[2]
└ constraints [6]
  ├ moai_ReLU[1] ≥ 0
  ├ moai_ReLU[1] ≤ 1
  ├ moai_ReLU[1] - max(0, x[1]) = 0
  ├ moai_ReLU[2] ≥ 0
  ├ moai_ReLU[2] ≤ 2
  └ moai_ReLU[2] - max(0, x[2]) = 0

julia&gt; y, formulation =
           MathOptAI.add_predictor(model, MathOptAI.ReducedSpace(f), x);

julia&gt; y
2-element Vector{NonlinearExpr}:
 max(0, x[1])
 max(0, x[2])

julia&gt; formulation
ReducedSpace(ReLU())
├ variables [0]
└ constraints [0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/predictors/ReLU.jl#L7-L61">source</a></section></details></article><h2 id="ReLUBigM"><a class="docs-heading-anchor" href="#ReLUBigM"><code>ReLUBigM</code></a><a id="ReLUBigM-1"></a><a class="docs-heading-anchor-permalink" href="#ReLUBigM" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.ReLUBigM"><a class="docstring-binding" href="#MathOptAI.ReLUBigM"><code>MathOptAI.ReLUBigM</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ReLUBigM(M::Float64) &lt;: AbstractPredictor</code></pre><p>An <a href="#AbstractPredictor"><code>AbstractPredictor</code></a> that represents the relationship:</p><p class="math-container">\[y = \max\{0, x\}\]</p><p>via the big-M MIP reformulation:</p><p class="math-container">\[\begin{aligned}
y \ge 0            \\
y \ge x            \\
y \le M z          \\
y \le x + M(1 - z) \\
z \in\{0, 1\}
\end{aligned}\]</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI

julia&gt; model = Model();

julia&gt; @variable(model, -3 &lt;= x[i in 1:2] &lt;= i);

julia&gt; f = MathOptAI.ReLUBigM(100.0)
ReLUBigM(100.0)

julia&gt; y, formulation = MathOptAI.add_predictor(model, f, x);

julia&gt; y
2-element Vector{VariableRef}:
 moai_ReLU[1]
 moai_ReLU[2]

julia&gt; formulation
ReLUBigM(100.0)
├ variables [4]
│ ├ moai_ReLU[1]
│ ├ moai_ReLU[2]
│ ├ moai_z[1]
│ └ moai_z[2]
└ constraints [12]
  ├ moai_ReLU[1] ≥ 0
  ├ moai_ReLU[1] ≤ 1
  ├ moai_z[1] binary
  ├ -x[1] + moai_ReLU[1] ≥ 0
  ├ moai_ReLU[1] - moai_z[1] ≤ 0
  ├ -x[1] + moai_ReLU[1] + 3 moai_z[1] ≤ 3
  ├ moai_ReLU[2] ≥ 0
  ├ moai_ReLU[2] ≤ 2
  ├ moai_z[2] binary
  ├ -x[2] + moai_ReLU[2] ≥ 0
  ├ moai_ReLU[2] - 2 moai_z[2] ≤ 0
  └ -x[2] + moai_ReLU[2] + 3 moai_z[2] ≤ 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/predictors/ReLUBigM.jl#L7-L65">source</a></section></details></article><h2 id="ReLUQuadratic"><a class="docs-heading-anchor" href="#ReLUQuadratic"><code>ReLUQuadratic</code></a><a id="ReLUQuadratic-1"></a><a class="docs-heading-anchor-permalink" href="#ReLUQuadratic" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.ReLUQuadratic"><a class="docstring-binding" href="#MathOptAI.ReLUQuadratic"><code>MathOptAI.ReLUQuadratic</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ReLUQuadratic(; relaxation_parameter = nothing) &lt;: AbstractPredictor</code></pre><p>An <a href="#AbstractPredictor"><code>AbstractPredictor</code></a> that represents the relationship:</p><p class="math-container">\[y = \max\{0, x\}\]</p><p>by the reformulation:</p><p class="math-container">\[\begin{aligned}
x = y - z \\
y \cdot z = 0 \\
y, z \ge 0
\end{aligned}\]</p><p>If <code>relaxation_parameter</code> is set to a value <code>ϵ</code>, the constraints become:</p><p class="math-container">\[\begin{aligned}
x = y - z \\
y \cdot z \leq \epsilon \\
y, z \ge 0
\end{aligned}\]</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI

julia&gt; model = Model();

julia&gt; @variable(model, -1 &lt;= x[i in 1:2] &lt;= i);

julia&gt; f = MathOptAI.ReLUQuadratic()
ReLUQuadratic(nothing)

julia&gt; y, formulation = MathOptAI.add_predictor(model, f, x);

julia&gt; y
2-element Vector{VariableRef}:
 moai_ReLU[1]
 moai_ReLU[2]

julia&gt; formulation
ReLUQuadratic(nothing)
├ variables [4]
│ ├ moai_ReLU[1]
│ ├ moai_ReLU[2]
│ ├ moai_z[1]
│ └ moai_z[2]
└ constraints [12]
  ├ moai_ReLU[1] ≥ 0
  ├ moai_ReLU[1] ≤ 1
  ├ moai_z[1] ≥ 0
  ├ moai_z[1] ≤ 1
  ├ x[1] - moai_ReLU[1] + moai_z[1] = 0
  ├ moai_ReLU[1]*moai_z[1] = 0
  ├ moai_ReLU[2] ≥ 0
  ├ moai_ReLU[2] ≤ 2
  ├ moai_z[2] ≥ 0
  ├ moai_z[2] ≤ 1
  ├ x[2] - moai_ReLU[2] + moai_z[2] = 0
  └ moai_ReLU[2]*moai_z[2] = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/predictors/ReLUQuadratic.jl#L7-L71">source</a></section></details></article><h2 id="ReLUSOS1"><a class="docs-heading-anchor" href="#ReLUSOS1"><code>ReLUSOS1</code></a><a id="ReLUSOS1-1"></a><a class="docs-heading-anchor-permalink" href="#ReLUSOS1" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.ReLUSOS1"><a class="docstring-binding" href="#MathOptAI.ReLUSOS1"><code>MathOptAI.ReLUSOS1</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ReLUSOS1() &lt;: AbstractPredictor</code></pre><p>An <a href="#AbstractPredictor"><code>AbstractPredictor</code></a> that represents the relationship:</p><p class="math-container">\[y = \max\{0, x\}\]</p><p>by the reformulation:</p><p class="math-container">\[\begin{aligned}
x = y - z           \\
[y, z] \in SOS1    \\
y, z \ge 0
\end{aligned}\]</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI

julia&gt; model = Model();

julia&gt; @variable(model, -1 &lt;= x[i in 1:2] &lt;= i);

julia&gt; f = MathOptAI.ReLUSOS1()
ReLUSOS1()

julia&gt; y, formulation = MathOptAI.add_predictor(model, f, x);

julia&gt; y
2-element Vector{VariableRef}:
 moai_ReLU[1]
 moai_ReLU[2]

julia&gt; formulation
ReLUSOS1()
├ variables [4]
│ ├ moai_ReLU[1]
│ ├ moai_ReLU[2]
│ ├ moai_z[1]
│ └ moai_z[2]
└ constraints [12]
  ├ moai_ReLU[1] ≥ 0
  ├ moai_ReLU[1] ≤ 1
  ├ moai_z[1] ≥ 0
  ├ moai_z[1] ≤ 1
  ├ x[1] - moai_ReLU[1] + moai_z[1] = 0
  ├ [moai_ReLU[1], moai_z[1]] ∈ MathOptInterface.SOS1{Float64}([1.0, 2.0])
  ├ moai_ReLU[2] ≥ 0
  ├ moai_ReLU[2] ≤ 2
  ├ moai_z[2] ≥ 0
  ├ moai_z[2] ≤ 1
  ├ x[2] - moai_ReLU[2] + moai_z[2] = 0
  └ [moai_ReLU[2], moai_z[2]] ∈ MathOptInterface.SOS1{Float64}([1.0, 2.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/predictors/ReLUSOS1.jl#L7-L63">source</a></section></details></article><h2 id="Scale"><a class="docs-heading-anchor" href="#Scale"><code>Scale</code></a><a id="Scale-1"></a><a class="docs-heading-anchor-permalink" href="#Scale" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.Scale"><a class="docstring-binding" href="#MathOptAI.Scale"><code>MathOptAI.Scale</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Scale(
    scale::Vector{T},
    bias::Vector{T},
) where {T} &lt;: AbstractPredictor</code></pre><p>An <a href="#AbstractPredictor"><code>AbstractPredictor</code></a> that represents the relationship:</p><p class="math-container">\[y = Diag(scale)x + bias\]</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI

julia&gt; model = Model();

julia&gt; @variable(model, 0 &lt;= x[i in 1:2] &lt;= i);

julia&gt; f = MathOptAI.Scale([2.0, 3.0], [4.0, 5.0])
Scale(scale, bias)

julia&gt; y, formulation = MathOptAI.add_predictor(model, f, x);

julia&gt; y
2-element Vector{VariableRef}:
 moai_Scale[1]
 moai_Scale[2]

julia&gt; formulation
Scale(scale, bias)
├ variables [2]
│ ├ moai_Scale[1]
│ └ moai_Scale[2]
└ constraints [6]
  ├ moai_Scale[1] ≥ 4
  ├ moai_Scale[1] ≤ 6
  ├ moai_Scale[2] ≥ 5
  ├ moai_Scale[2] ≤ 11
  ├ 2 x[1] - moai_Scale[1] = -4
  └ 3 x[2] - moai_Scale[2] = -5

julia&gt; y, formulation =
           MathOptAI.add_predictor(model, MathOptAI.ReducedSpace(f), x);

julia&gt; y
2-element Vector{AffExpr}:
 2 x[1] + 4
 3 x[2] + 5

julia&gt; formulation
ReducedSpace(Scale(scale, bias))
├ variables [0]
└ constraints [0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/predictors/Scale.jl#L7-L63">source</a></section></details></article><h2 id="Sigmoid"><a class="docs-heading-anchor" href="#Sigmoid"><code>Sigmoid</code></a><a id="Sigmoid-1"></a><a class="docs-heading-anchor-permalink" href="#Sigmoid" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.Sigmoid"><a class="docstring-binding" href="#MathOptAI.Sigmoid"><code>MathOptAI.Sigmoid</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Sigmoid() &lt;: AbstractPredictor</code></pre><p>An <a href="#AbstractPredictor"><code>AbstractPredictor</code></a> that represents the relationship:</p><p class="math-container">\[y = \frac{1}{1 + e^{-x}}\]</p><p>as a smooth nonlinear constraint.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI

julia&gt; model = Model();

julia&gt; @variable(model, -1 &lt;= x[i in 1:2] &lt;= i);

julia&gt; f = MathOptAI.Sigmoid()
Sigmoid()

julia&gt; y, formulation = MathOptAI.add_predictor(model, f, x);

julia&gt; y
2-element Vector{VariableRef}:
 moai_Sigmoid[1]
 moai_Sigmoid[2]

julia&gt; formulation
Sigmoid()
├ variables [2]
│ ├ moai_Sigmoid[1]
│ └ moai_Sigmoid[2]
└ constraints [6]
  ├ moai_Sigmoid[1] ≥ 0.2689414213699951
  ├ moai_Sigmoid[1] ≤ 0.7310585786300049
  ├ moai_Sigmoid[1] - (1 / (1 + exp(-x[1]))) = 0
  ├ moai_Sigmoid[2] ≥ 0.2689414213699951
  ├ moai_Sigmoid[2] ≤ 0.8807970779778823
  └ moai_Sigmoid[2] - (1 / (1 + exp(-x[2]))) = 0

julia&gt; y, formulation =
           MathOptAI.add_predictor(model, MathOptAI.ReducedSpace(f), x);

julia&gt; y
2-element Vector{NonlinearExpr}:
 1 / (1 + exp(-x[1]))
 1 / (1 + exp(-x[2]))

julia&gt; formulation
ReducedSpace(Sigmoid())
├ variables [0]
└ constraints [0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/predictors/Sigmoid.jl#L7-L61">source</a></section></details></article><h2 id="SoftMax"><a class="docs-heading-anchor" href="#SoftMax"><code>SoftMax</code></a><a id="SoftMax-1"></a><a class="docs-heading-anchor-permalink" href="#SoftMax" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.SoftMax"><a class="docstring-binding" href="#MathOptAI.SoftMax"><code>MathOptAI.SoftMax</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SoftMax() &lt;: AbstractPredictor</code></pre><p>An <a href="#AbstractPredictor"><code>AbstractPredictor</code></a> that represents the relationship:</p><p class="math-container">\[y = \frac{e^{x}}{||e^{x}||_1}\]</p><p>as a smooth nonlinear constraint.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI

julia&gt; model = Model();

julia&gt; @variable(model, x[1:2]);

julia&gt; f = MathOptAI.SoftMax()
SoftMax()

julia&gt; y, formulation = MathOptAI.add_predictor(model, f, x);

julia&gt; y
2-element Vector{VariableRef}:
 moai_SoftMax[1]
 moai_SoftMax[2]

julia&gt; formulation
SoftMax()
├ variables [3]
│ ├ moai_SoftMax_denom[1]
│ ├ moai_SoftMax[1]
│ └ moai_SoftMax[2]
└ constraints [8]
  ├ moai_SoftMax_denom[1] ≥ 0
  ├ moai_SoftMax_denom[1] - (0 + exp(x[2]) + exp(x[1])) = 0
  ├ moai_SoftMax[1] ≥ 0
  ├ moai_SoftMax[1] ≤ 1
  ├ moai_SoftMax[1] - (exp(x[1]) / moai_SoftMax_denom[1]) = 0
  ├ moai_SoftMax[2] ≥ 0
  ├ moai_SoftMax[2] ≤ 1
  └ moai_SoftMax[2] - (exp(x[2]) / moai_SoftMax_denom[1]) = 0

julia&gt; y, formulation =
           MathOptAI.add_predictor(model, MathOptAI.ReducedSpace(f), x);

julia&gt; y
2-element Vector{NonlinearExpr}:
 exp(x[1]) / moai_SoftMax_denom[1]
 exp(x[2]) / moai_SoftMax_denom[1]

julia&gt; formulation
ReducedSpace(SoftMax())
├ variables [1]
│ └ moai_SoftMax_denom[1]
└ constraints [2]
  ├ moai_SoftMax_denom[1] ≥ 0
  └ moai_SoftMax_denom[1] - (0 + exp(x[2]) + exp(x[1])) = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/predictors/SoftMax.jl#L7-L67">source</a></section></details></article><h2 id="SoftPlus"><a class="docs-heading-anchor" href="#SoftPlus"><code>SoftPlus</code></a><a id="SoftPlus-1"></a><a class="docs-heading-anchor-permalink" href="#SoftPlus" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.SoftPlus"><a class="docstring-binding" href="#MathOptAI.SoftPlus"><code>MathOptAI.SoftPlus</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SoftPlus(; beta = 1.0) &lt;: AbstractPredictor</code></pre><p>An <a href="#AbstractPredictor"><code>AbstractPredictor</code></a> that represents the relationship:</p><p class="math-container">\[y = \frac{1}{\beta} \log(1 + e^{\beta x})\]</p><p>as a smooth nonlinear constraint.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI

julia&gt; model = Model();

julia&gt; @variable(model, -1 &lt;= x[i in 1:2] &lt;= i);

julia&gt; f = MathOptAI.SoftPlus(; beta = 2.0)
SoftPlus(2.0)

julia&gt; y, formulation = MathOptAI.add_predictor(model, f, x);

julia&gt; y
2-element Vector{VariableRef}:
 moai_SoftPlus[1]
 moai_SoftPlus[2]

julia&gt; formulation
SoftPlus(2.0)
├ variables [2]
│ ├ moai_SoftPlus[1]
│ └ moai_SoftPlus[2]
└ constraints [6]
  ├ moai_SoftPlus[1] ≥ 0.0634640055214863
  ├ moai_SoftPlus[1] ≤ 1.0634640055214863
  ├ moai_SoftPlus[1] - (log(1 + exp(2 x[1])) / 2) = 0
  ├ moai_SoftPlus[2] ≥ 0.0634640055214863
  ├ moai_SoftPlus[2] ≤ 2.0090749639589047
  └ moai_SoftPlus[2] - (log(1 + exp(2 x[2])) / 2) = 0

julia&gt; y, formulation =
           MathOptAI.add_predictor(model, MathOptAI.ReducedSpace(f), x);

julia&gt; y
2-element Vector{NonlinearExpr}:
 log(1 + exp(2 x[1])) / 2
 log(1 + exp(2 x[2])) / 2

julia&gt; formulation
ReducedSpace(SoftPlus(2.0))
├ variables [0]
└ constraints [0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/predictors/SoftPlus.jl#L7-L61">source</a></section></details></article><h2 id="TAGConv"><a class="docs-heading-anchor" href="#TAGConv"><code>TAGConv</code></a><a id="TAGConv-1"></a><a class="docs-heading-anchor-permalink" href="#TAGConv" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.TAGConv"><a class="docstring-binding" href="#MathOptAI.TAGConv"><code>MathOptAI.TAGConv</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TAGConv(;
    weights::Vector{Matrix{T}},
    bias::Vector{T},
    edge_index::Vector{Pair{Int,Int}},
)</code></pre><p>An <a href="#AbstractPredictor"><code>AbstractPredictor</code></a> that represents a topology adaptive graph convolutional network operator:</p><p class="math-container">\[Y = \sum\limits_{k=0}^K (D^{-1/2} A D^{-1/2})^k X W_k + b\]</p><p>where:</p><ul><li><span>$W_k$</span> is <code>weights[k+1]</code></li><li><span>$A$</span> is the adjacency matrix constructed from <code>edge_index</code></li><li><span>$b$</span> is the bias vector <code>bias</code></li><li><span>$D$</span> is the diagonal degree matrix.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI

julia&gt; model = Model();

julia&gt; @variable(model, x[1:3, 1:2]);

julia&gt; f = MathOptAI.TAGConv(;
           weights = Matrix{Float64}[[1 2]&#39;, [3 4]&#39;, [5 6]&#39;],
           bias = [7.0],
           edge_index = [1 =&gt; 2, 2 =&gt; 1, 2 =&gt; 3, 3 =&gt; 2],
       );

julia&gt; y, formulation = MathOptAI.add_predictor(model, f, vec(x));

julia&gt; y
3-element Vector{VariableRef}:
 moai_TAGConv[1]
 moai_TAGConv[2]
 moai_TAGConv[3]

julia&gt; formulation
TAGConv{Float64}([[1.0; 2.0;;], [3.0; 4.0;;], [5.0; 6.0;;]], [7.0], [0.0 0.7071067811865475 0.0; 0.7071067811865475 0.0 0.7071067811865475; 0.0 0.7071067811865475 0.0])
├ variables [3]
│ ├ moai_TAGConv[1]
│ ├ moai_TAGConv[2]
│ └ moai_TAGConv[3]
└ constraints [3]
  ├ -3.4999999999999996 x[1,1] - 2.1213203435596424 x[2,1] - 2.4999999999999996 x[3,1] - 4.999999999999999 x[1,2] - 2.82842712474619 x[2,2] - 2.999999999999999 x[3,2] + moai_TAGConv[1] = 7
  ├ -2.1213203435596424 x[1,1] - 5.999999999999999 x[2,1] - 2.1213203435596424 x[3,1] - 2.82842712474619 x[1,2] - 7.999999999999998 x[2,2] - 2.82842712474619 x[3,2] + moai_TAGConv[2] = 7
  └ -2.4999999999999996 x[1,1] - 2.1213203435596424 x[2,1] - 3.4999999999999996 x[3,1] - 2.999999999999999 x[1,2] - 2.82842712474619 x[2,2] - 4.999999999999999 x[3,2] + moai_TAGConv[3] = 7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/predictors/TAGConv.jl#L7-L60">source</a></section></details></article><h2 id="Tanh"><a class="docs-heading-anchor" href="#Tanh"><code>Tanh</code></a><a id="Tanh-1"></a><a class="docs-heading-anchor-permalink" href="#Tanh" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.Tanh"><a class="docstring-binding" href="#MathOptAI.Tanh"><code>MathOptAI.Tanh</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Tanh() &lt;: AbstractPredictor</code></pre><p>An <a href="#AbstractPredictor"><code>AbstractPredictor</code></a> that represents the relationship:</p><p class="math-container">\[y = \tanh(x)\]</p><p>as a smooth nonlinear constraint.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI

julia&gt; model = Model();

julia&gt; @variable(model, -1 &lt;= x[i in 1:2] &lt;= i);

julia&gt; f = MathOptAI.Tanh()
Tanh()

julia&gt; y, formulation = MathOptAI.add_predictor(model, f, x);

julia&gt; y
2-element Vector{VariableRef}:
 moai_Tanh[1]
 moai_Tanh[2]

julia&gt; formulation
Tanh()
├ variables [2]
│ ├ moai_Tanh[1]
│ └ moai_Tanh[2]
└ constraints [6]
  ├ moai_Tanh[1] ≥ -0.7615941559557649
  ├ moai_Tanh[1] ≤ 0.7615941559557649
  ├ moai_Tanh[1] - tanh(x[1]) = 0
  ├ moai_Tanh[2] ≥ -0.7615941559557649
  ├ moai_Tanh[2] ≤ 0.9640275800758169
  └ moai_Tanh[2] - tanh(x[2]) = 0

julia&gt; y, formulation =
           MathOptAI.add_predictor(model, MathOptAI.ReducedSpace(f), x);

julia&gt; y
2-element Vector{NonlinearExpr}:
 tanh(x[1])
 tanh(x[2])

julia&gt; formulation
ReducedSpace(Tanh())
├ variables [0]
└ constraints [0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/predictors/Tanh.jl#L7-L61">source</a></section></details></article><h2 id="AbstractFormulation"><a class="docs-heading-anchor" href="#AbstractFormulation"><code>AbstractFormulation</code></a><a id="AbstractFormulation-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractFormulation" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.AbstractFormulation"><a class="docstring-binding" href="#MathOptAI.AbstractFormulation"><code>MathOptAI.AbstractFormulation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbstractFormulation end</code></pre><p>An abstract type representing different formulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/MathOptAI.jl#L31-L35">source</a></section></details></article><h2 id="Formulation"><a class="docs-heading-anchor" href="#Formulation"><code>Formulation</code></a><a id="Formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Formulation" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.Formulation"><a class="docstring-binding" href="#MathOptAI.Formulation"><code>MathOptAI.Formulation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Formulation{P&lt;:AbstractPredictor} &lt;: AbstractFormulation
    predictor::P
    variables::Vector{Any}
    constraints::Vector{Any}
end</code></pre><p><strong>Fields</strong></p><ul><li><code>predictor</code>: the predictor object used to build the formulation</li><li><code>variables</code>: a vector of new decision variables added to the model</li><li><code>constraints</code>: a vector of new constraints added to the model</li></ul><p>Check the docstring of the predictor for an explanation of the formulation and the order of the elements in <code>.variables</code> and <code>.constraints</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/MathOptAI.jl#L38-L53">source</a></section></details></article><h2 id="PipelineFormulation"><a class="docs-heading-anchor" href="#PipelineFormulation"><code>PipelineFormulation</code></a><a id="PipelineFormulation-1"></a><a class="docs-heading-anchor-permalink" href="#PipelineFormulation" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.PipelineFormulation"><a class="docstring-binding" href="#MathOptAI.PipelineFormulation"><code>MathOptAI.PipelineFormulation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct PipelineFormulation{P&lt;:AbstractPredictor} &lt;: AbstractFormulation
    predictor::P
    layers::Vector{Any}
end</code></pre><p><strong>Fields</strong></p><ul><li><code>predictor</code>: the predictor object used to build the formulation</li><li><code>layers</code>: the formulation associated with each of the layers in the pipeline</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/MathOptAI.jl#L91-L101">source</a></section></details></article><h2 id="AbstractGPs"><a class="docs-heading-anchor" href="#AbstractGPs"><code>AbstractGPs</code></a><a id="AbstractGPs-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractGPs" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.add_predictor-Tuple{JuMP.AbstractModel, MathOptAI.Quantile{&lt;:AbstractGPs.PosteriorGP}, Vector}"><a class="docstring-binding" href="#MathOptAI.add_predictor-Tuple{JuMP.AbstractModel, MathOptAI.Quantile{&lt;:AbstractGPs.PosteriorGP}, Vector}"><code>MathOptAI.add_predictor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MathOptAI.add_predictor(
    model::JuMP.AbstractModel,
    predictor::MathOptAI.Quantile{&lt;:AbstractGPs.PosteriorGP},
    x::Vector,
)</code></pre><p>Add the quantiles of a trained Gaussian Process from AbstractGPs.jl to <code>model</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI, AbstractGPs

julia&gt; x_data = 2π .* (0.0:0.1:1.0);

julia&gt; y_data = sin.(x_data);

julia&gt; fx = AbstractGPs.GP(AbstractGPs.Matern32Kernel())(x_data, 0.1);

julia&gt; p_fx = AbstractGPs.posterior(fx, y_data);

julia&gt; model = Model();

julia&gt; @variable(model, 1 &lt;= x[1:1] &lt;= 6, start = 3);

julia&gt; predictor = MathOptAI.Quantile(p_fx, [0.1, 0.9]);

julia&gt; y, _ = MathOptAI.add_predictor(model, predictor, x);

julia&gt; y
2-element Vector{VariableRef}:
 moai_quantile[1]
 moai_quantile[2]

julia&gt; @objective(model, Max, y[2] - y[1])
moai_quantile[2] - moai_quantile[1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/ext/MathOptAIAbstractGPsExt.jl#L14-L52">source</a></section></details></article><h2 id="DecisionTree"><a class="docs-heading-anchor" href="#DecisionTree"><code>DecisionTree</code></a><a id="DecisionTree-1"></a><a class="docs-heading-anchor-permalink" href="#DecisionTree" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.build_predictor-Tuple{Union{DecisionTree.DecisionTreeClassifier, DecisionTree.Ensemble, DecisionTree.Leaf, DecisionTree.Node, DecisionTree.Root}}"><a class="docstring-binding" href="#MathOptAI.build_predictor-Tuple{Union{DecisionTree.DecisionTreeClassifier, DecisionTree.Ensemble, DecisionTree.Leaf, DecisionTree.Node, DecisionTree.Root}}"><code>MathOptAI.build_predictor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MathOptAI.build_predictor(
    predictor::Union{
        DecisionTree.Ensemble,
        DecisionTree.DecisionTreeClassifier,
        DecisionTree.Leaf,
        DecisionTree.Node,
        DecisionTree.Root,
    },
)</code></pre><p>Convert a binary decision tree from DecisionTree.jl to a <a href="#BinaryDecisionTree"><code>BinaryDecisionTree</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI, DecisionTree

julia&gt; truth(x::Vector) = x[1] &lt;= 0.5 ? -2 : (x[2] &lt;= 0.3 ? 3 : 4)
truth (generic function with 1 method)

julia&gt; features = abs.(sin.((1:10) .* (3:4)&#39;));

julia&gt; size(features)
(10, 2)

julia&gt; labels = truth.(Vector.(eachrow(features)));

julia&gt; tree = DecisionTree.build_tree(labels, features)
Decision Tree
Leaves: 3
Depth:  2

julia&gt; model = Model();

julia&gt; @variable(model, 0 &lt;= x[1:2] &lt;= 1);

julia&gt; y, _ = MathOptAI.add_predictor(model, tree, x);

julia&gt; y
1-element Vector{VariableRef}:
 moai_BinaryDecisionTree_value[1]

julia&gt; MathOptAI.build_predictor(tree)
BinaryDecisionTree{Float64,Int64} [leaves=3, depth=2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/ext/MathOptAIDecisionTreeExt.jl#L13-L60">source</a></section></details></article><h2 id="EvoTrees"><a class="docs-heading-anchor" href="#EvoTrees"><code>EvoTrees</code></a><a id="EvoTrees-1"></a><a class="docs-heading-anchor-permalink" href="#EvoTrees" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.build_predictor-Union{Tuple{EvoTrees.EvoTree{L, 1}}, Tuple{L}} where L"><a class="docstring-binding" href="#MathOptAI.build_predictor-Union{Tuple{EvoTrees.EvoTree{L, 1}}, Tuple{L}} where L"><code>MathOptAI.build_predictor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MathOptAI.build_predictor(predictor::EvoTrees.EvoTree{L,1}) where {L}</code></pre><p>Convert a boosted tree from EvoTrees.jl to an <a href="#AffineCombination"><code>AffineCombination</code></a> of <a href="#BinaryDecisionTree"><code>BinaryDecisionTree</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI, EvoTrees

julia&gt; truth(x::Vector) = x[1] &lt;= 0.5 ? -2 : (x[2] &lt;= 0.3 ? 3 : 4)
truth (generic function with 1 method)

julia&gt; x_train = abs.(sin.((1:10) .* (3:4)&#39;));

julia&gt; size(x_train)
(10, 2)

julia&gt; y_train = truth.(Vector.(eachrow(x_train)));

julia&gt; config = EvoTrees.EvoTreeRegressor(; nrounds = 3);

julia&gt; tree = EvoTrees.fit(config; x_train, y_train);

julia&gt; model = Model();

julia&gt; @variable(model, 0 &lt;= x[1:2] &lt;= 1);

julia&gt; y, _ = MathOptAI.add_predictor(model, tree, x);

julia&gt; y
1-element Vector{VariableRef}:
 moai_AffineCombination[1]

julia&gt; MathOptAI.build_predictor(tree)
AffineCombination
├ 1.0 * BinaryDecisionTree{Float64,Float64} [leaves=3, depth=2]
├ 1.0 * BinaryDecisionTree{Float64,Float64} [leaves=3, depth=2]
├ 1.0 * BinaryDecisionTree{Float64,Float64} [leaves=3, depth=2]
└ 1.0 * [2.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/ext/MathOptAIEvoTreesExt.jl#L13-L55">source</a></section></details></article><h2 id="Flux"><a class="docs-heading-anchor" href="#Flux"><code>Flux</code></a><a id="Flux-1"></a><a class="docs-heading-anchor-permalink" href="#Flux" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.build_predictor-Tuple{Flux.Chain}"><a class="docstring-binding" href="#MathOptAI.build_predictor-Tuple{Flux.Chain}"><code>MathOptAI.build_predictor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MathOptAI.build_predictor(
    predictor::Flux.Chain;
    config::Dict = Dict{Any,Any}(),
    gray_box::Bool = false,
    hessian::Bool = gray_box,
    input_size::Union{Nothing,NTuple{N,Int}} = nothing,
)</code></pre><p>Convert a trained neural network from Flux.jl to a <a href="#Pipeline"><code>Pipeline</code></a>.</p><p><strong>Supported layers</strong></p><ul><li><code>Flux.Conv</code></li><li><code>Flux.Dense</code></li><li><code>Flux.flatten</code></li><li><code>Flux.LayerNorm</code></li><li><code>Flux.MaxPool</code></li><li><code>Flux.MeanPool</code></li><li><code>Flux.Scale</code></li><li><code>Flux.softmax</code></li></ul><p><strong>Supported activation functions</strong></p><ul><li><code>Flux.relu</code></li><li><code>Flux.sigmoid</code></li><li><code>Flux.softplus</code></li><li><code>Flux.tanh</code></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>config</code>: see the <code>Config</code> section below.</p></li><li><p><code>gray_box</code>: if <code>true</code>, the neural network is added using a <a href="#GrayBox"><code>GrayBox</code></a> formulation.</p></li><li><p><code>hessian</code>: if <code>true</code>, the <code>gray_box</code> formulations compute the Hessian of the output using <code>Flux.hessian</code>. The default for <code>hessian</code> is <code>true</code> if <code>gray_box</code> is used.</p></li><li><p><code>input_size</code>: to disambiguate the input and output sizes of matrix inputs, chains containing <code>Conv</code>, <code>LayerNorm</code>, <code>MaxPool</code>, and <code>MeanPool</code> layers must specify an initial input size.</p></li></ul><p><strong>Config</strong></p><p>The <code>config</code> dictionary controls how layers in Flux are mapped to <a href="#AbstractPredictor"><code>AbstractPredictor</code></a>s.</p><p>Supported keys and and example key-value pairs are:</p><ul><li><code>Flux.MaxPool =&gt; (k; kwargs...) -&gt; MathOptAI.MaxPool2dBigM(k; M = 10.0, kwargs...)</code></li><li><code>Flux.relu =&gt; MathOptAI.ReLU</code></li><li><code>Flux.sigmoid =&gt; MathOptAI.Sigmoid</code></li><li><code>Flux.softmax =&gt; MathOptAI.SoftMax</code></li><li><code>Flux.softplus =&gt; MathOptAI.SoftPlus</code></li><li><code>Flux.tanh =&gt; MathOptAI.Tanh</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI, Flux

julia&gt; chain = Flux.Chain(Flux.Dense(1 =&gt; 16, Flux.relu), Flux.Dense(16 =&gt; 1));

julia&gt; model = Model();

julia&gt; @variable(model, x[1:1]);

julia&gt; y, _ = MathOptAI.add_predictor(
           model,
           chain,
           x;
           config = Dict(Flux.relu =&gt; MathOptAI.ReLU),
       );

julia&gt; y
1-element Vector{VariableRef}:
 moai_Affine[1]

julia&gt; MathOptAI.build_predictor(
           chain;
           config = Dict(Flux.relu =&gt; MathOptAI.ReLU),
       )
Pipeline with layers:
 * Affine(A, b) [input: 1, output: 16]
 * ReLU()
 * Affine(A, b) [input: 16, output: 1]

julia&gt; MathOptAI.build_predictor(
           chain;
           config = Dict(Flux.relu =&gt; MathOptAI.ReLUQuadratic),
       )
Pipeline with layers:
 * Affine(A, b) [input: 1, output: 16]
 * ReLUQuadratic(nothing)
 * Affine(A, b) [input: 16, output: 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/ext/MathOptAIFluxExt.jl#L14-L112">source</a></section></details></article><h2 id="GLM"><a class="docs-heading-anchor" href="#GLM"><code>GLM</code></a><a id="GLM-1"></a><a class="docs-heading-anchor-permalink" href="#GLM" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.build_predictor-Tuple{GLM.GeneralizedLinearModel{GLM.GlmResp{Vector{Float64}, Distributions.Bernoulli{Float64}, GLM.LogitLink}}}"><a class="docstring-binding" href="#MathOptAI.build_predictor-Tuple{GLM.GeneralizedLinearModel{GLM.GlmResp{Vector{Float64}, Distributions.Bernoulli{Float64}, GLM.LogitLink}}}"><code>MathOptAI.build_predictor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MathOptAI.build_predictor(
    predictor::GLM.GeneralizedLinearModel{
        GLM.GlmResp{Vector{Float64},GLM.Bernoulli{Float64},GLM.LogitLink},
    };
    sigmoid::MathOptAI.AbstractPredictor = MathOptAI.Sigmoid(),
)</code></pre><p>Convert a trained logistic model from GLM.jl to a <a href="#Pipeline"><code>Pipeline</code></a> layer.</p><p><strong>Keyword arguments</strong></p><ul><li><code>sigmoid</code>: the predictor to use for the sigmoid layer.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI, GLM

julia&gt; X, Y = rand(10, 2), rand(Bool, 10);

julia&gt; predictor = GLM.glm(X, Y, GLM.Bernoulli());

julia&gt; model = Model();

julia&gt; @variable(model, x[1:2]);

julia&gt; y, _ = MathOptAI.add_predictor(
           model,
           predictor,
           x;
           sigmoid = MathOptAI.Sigmoid(),
       );

julia&gt; y
1-element Vector{VariableRef}:
 moai_Sigmoid[1]

julia&gt; MathOptAI.build_predictor(predictor)
Pipeline with layers:
 * Affine(A, b) [input: 2, output: 1]
 * Sigmoid()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/ext/MathOptAIGLMExt.jl#L45-L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptAI.build_predictor-Tuple{GLM.LinearModel}"><a class="docstring-binding" href="#MathOptAI.build_predictor-Tuple{GLM.LinearModel}"><code>MathOptAI.build_predictor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MathOptAI.build_predictor(predictor::GLM.LinearModel)</code></pre><p>Convert a trained linear model from GLM.jl to an <a href="#Affine"><code>Affine</code></a> layer.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI, GLM

julia&gt; X, Y = rand(10, 2), rand(10);

julia&gt; predictor = GLM.lm(X, Y);

julia&gt; model = Model();

julia&gt; @variable(model, x[1:2]);

julia&gt; y, _ = MathOptAI.add_predictor(model, predictor, x);

julia&gt; y
1-element Vector{VariableRef}:
 moai_Affine[1]

julia&gt; MathOptAI.build_predictor(predictor)
Affine(A, b) [input: 2, output: 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/ext/MathOptAIGLMExt.jl#L13-L40">source</a></section></details></article><h2 id="Lux"><a class="docs-heading-anchor" href="#Lux"><code>Lux</code></a><a id="Lux-1"></a><a class="docs-heading-anchor-permalink" href="#Lux" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.build_predictor-Tuple{Tuple{Lux.Chain, NamedTuple, NamedTuple}}"><a class="docstring-binding" href="#MathOptAI.build_predictor-Tuple{Tuple{Lux.Chain, NamedTuple, NamedTuple}}"><code>MathOptAI.build_predictor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MathOptAI.build_predictor(
    predictor::Tuple{&lt;:Lux.Chain,&lt;:NamedTuple,&lt;:NamedTuple};
    config::Dict = Dict{Any,Any}(),
)</code></pre><p>Convert a trained neural network from Lux.jl to a <a href="#Pipeline"><code>Pipeline</code></a>.</p><p><strong>Supported layers</strong></p><ul><li><code>Lux.Dense</code></li><li><code>Lux.Scale</code></li></ul><p><strong>Supported activation functions</strong></p><ul><li><code>Lux.relu</code></li><li><code>Lux.sigmoid</code></li><li><code>Lux.softplus</code></li><li><code>Lux.softmax</code></li><li><code>Lux.tanh</code></li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>config</code>: see the <code>Config</code> section below.</li></ul><p><strong>Config</strong></p><p>The <code>config</code> dictionary controls how layers in Flux are mapped to <a href="#AbstractPredictor"><code>AbstractPredictor</code></a>s.</p><p>Supported keys and and example key-value pairs are:</p><ul><li><code>Lux.relu =&gt; MathOptAI.ReLU</code></li><li><code>Lux.sigmoid =&gt; MathOptAI.Sigmoid</code></li><li><code>Lux.sigmoid_fast =&gt; MathOptAI.Sigmoid</code></li><li><code>Lux.softmax =&gt; MathOptAI.SoftMax</code></li><li><code>Lux.softplus =&gt; MathOptAI.SoftPlus</code></li><li><code>Lux.tanh =&gt; MathOptAI.Tanh</code></li><li><code>Lux.tanh_fast =&gt; MathOptAI.Tanh</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, MathOptAI, Lux, Random

julia&gt; rng = Random.MersenneTwister();

julia&gt; chain = Lux.Chain(Lux.Dense(1 =&gt; 16, Lux.relu), Lux.Dense(16 =&gt; 1))
Chain(
    layer_1 = Dense(1 =&gt; 16, relu),               # 32 parameters
    layer_2 = Dense(16 =&gt; 1),                     # 17 parameters
)         # Total: 49 parameters,
          #        plus 0 states.

julia&gt; parameters, state = Lux.setup(rng, chain);

julia&gt; model = Model();

julia&gt; @variable(model, x[1:1]);

julia&gt; y, _ = MathOptAI.add_predictor(
           model,
           (chain, parameters, state),
           x;
           config = Dict(Lux.relu =&gt; MathOptAI.ReLU),
       );

julia&gt; y
1-element Vector{VariableRef}:
 moai_Affine[1]

julia&gt; MathOptAI.build_predictor(
           (chain, parameters, state);
           config = Dict(Lux.relu =&gt; MathOptAI.ReLU),
       )
Pipeline with layers:
 * Affine(A, b) [input: 1, output: 16]
 * ReLU()
 * Affine(A, b) [input: 16, output: 1]

julia&gt; MathOptAI.build_predictor(
           (chain, parameters, state);
           config = Dict(Lux.relu =&gt; MathOptAI.ReLUQuadratic),
       )
Pipeline with layers:
 * Affine(A, b) [input: 1, output: 16]
 * ReLUQuadratic(nothing)
 * Affine(A, b) [input: 16, output: 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/ext/MathOptAILuxExt.jl#L13-L102">source</a></section></details></article><h2 id="PythonCall"><a class="docs-heading-anchor" href="#PythonCall"><code>PythonCall</code></a><a id="PythonCall-1"></a><a class="docs-heading-anchor-permalink" href="#PythonCall" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.GCNConv-Tuple{PythonCall.Py}"><a class="docstring-binding" href="#MathOptAI.GCNConv-Tuple{PythonCall.Py}"><code>MathOptAI.GCNConv</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MathOptAI.GCNConv(
    layer::PythonCall.Py;
    edge_index::Vector{Pair{Int,Int}},
)</code></pre><p>Create a <a href="#GCNConv"><code>GCNConv</code></a> layer from a <code>torch_geometric.nn.GCNConv</code> layer.</p><p>See the <a href="../tutorials/graph_neural_networks/#Graph-neural-networks">Graph neural networks</a> tutorial for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/ext/MathOptAIPythonCallExt.jl#L356-L365">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptAI.TAGConv-Tuple{PythonCall.Py}"><a class="docstring-binding" href="#MathOptAI.TAGConv-Tuple{PythonCall.Py}"><code>MathOptAI.TAGConv</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MathOptAI.TAGConv(
    layer::PythonCall.Py;
    edge_index::Vector{Pair{Int,Int}},
)</code></pre><p>Create a <a href="#TAGConv"><code>TAGConv</code></a> layer from a <code>torch_geometric.nn.TAGConv</code> layer.</p><p>See the <a href="../tutorials/graph_neural_networks/#Graph-neural-networks">Graph neural networks</a> tutorial for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/ext/MathOptAIPythonCallExt.jl#L377-L386">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptAI.build_predictor-Tuple{MathOptAI.PytorchModel}"><a class="docstring-binding" href="#MathOptAI.build_predictor-Tuple{MathOptAI.PytorchModel}"><code>MathOptAI.build_predictor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MathOptAI.build_predictor(
    predictor::MathOptAI.PytorchModel;
    config::Dict = Dict{Any,Any}(),
    gray_box::Bool = false,
    hessian::Bool = gray_box,
    device::String = &quot;cpu&quot;,
    input_size::Union{Nothing,NTuple{N,Int}} = nothing,
)</code></pre><p>Convert a trained neural network from PyTorch via PythonCall.jl to a <a href="#Pipeline"><code>Pipeline</code></a>.</p><p><strong>Supported layers</strong></p><ul><li><code>nn.AvgPool2d</code></li><li><code>nn.Conv2d</code></li><li><code>nn.Dropout</code></li><li><code>nn.Flatten</code></li><li><code>nn.GELU</code></li><li><code>nn.LayerNorm</code></li><li><code>nn.LeakyReLU</code></li><li><code>nn.Linear</code></li><li><code>nn.MaxPool2d</code></li><li><code>nn.ReLU</code></li><li><code>nn.Sequential</code></li><li><code>nn.Sigmoid</code></li><li><code>nn.Softmax</code></li><li><code>nn.Softplus</code></li><li><code>nn.Tanh</code></li></ul><p>Note that <code>nn.Dropout</code> layers are skipped because we assume that the PyTorch model is being evaluated, not trained.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>config</code>: see the <code>Config</code> section below.</p></li><li><p><code>gray_box</code>: if <code>true</code>, the neural network is added using a <a href="#GrayBox"><code>GrayBox</code></a> formulation.</p></li><li><p><code>hessian</code>: if <code>true</code>, the <code>gray_box</code> formulation computes the Hessian of the output using <code>torch.func.hessian</code>. The default for <code>hessian</code> is <code>true</code> if <code>gray_box</code> is used.</p></li><li><p><code>device</code>: device used to construct PyTorch tensors, for example, <code>&quot;cuda&quot;</code> to run on an Nvidia GPU.</p></li><li><p><code>input_size</code>: to disambiguate the input and output sizes of matrix inputs, models containing <code>AvgPool2d</code>, <code>Conv2d</code>, and <code>MaxPool2d</code> layers must specify an initial input size.</p></li></ul><p><strong>Config</strong></p><p>The <code>config</code> dictionary controls how layers in PyTorch are mapped to <a href="#AbstractPredictor"><code>AbstractPredictor</code></a>s.</p><p>Supported keys and and example key-value pairs are:</p><ul><li><code>:GELU =&gt; MathOptAI.GELU</code></li><li><code>:MaxPool2d =&gt; (k; kwargs...) -&gt; MathOptAI.MaxPool2dBigM(k; M = 10.0, kwargs...)</code></li><li><code>:ReLU =&gt; MathOptAI.ReLU</code></li><li><code>:Sigmoid =&gt; MathOptAI.Sigmoid</code></li><li><code>:SoftMax =&gt; MathOptAI.SoftMax</code></li><li><code>:SoftPlus =&gt; (; beta) -&gt; MathOptAI.SoftPlus(; beta)</code></li><li><code>:Tanh =&gt; MathOptAI.Tanh</code></li></ul><p>Note that <code>:LeakyReLU</code> is not supported. Use <code>:ReLU</code> to control how the inner ReLU is modeled.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/ext/MathOptAIPythonCallExt.jl#L14-L83">source</a></section></details></article><h2 id="StatsModels"><a class="docs-heading-anchor" href="#StatsModels"><code>StatsModels</code></a><a id="StatsModels-1"></a><a class="docs-heading-anchor-permalink" href="#StatsModels" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.add_predictor-Tuple{JuMP.AbstractModel, StatsModels.TableRegressionModel, DataFrames.DataFrame}"><a class="docstring-binding" href="#MathOptAI.add_predictor-Tuple{JuMP.AbstractModel, StatsModels.TableRegressionModel, DataFrames.DataFrame}"><code>MathOptAI.add_predictor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MathOptAI.add_predictor(
    model::JuMP.AbstractModel,
    predictor::StatsModels.TableRegressionModel,
    x::DataFrames.DataFrame;
    kwargs...,
)</code></pre><p>Add a trained regression model from StatsModels.jl to <code>model</code>, using the DataFrame <code>x</code> as input.</p><p>In most cases, <code>predictor</code> should be a GLM.jl predictor supported by MathOptAI, but trained using <code>@formula</code> and a <code>DataFrame</code> instead of the raw matrix input.</p><p>In general, <code>x</code> may have some columns that are constant (<code>Float64</code>) and some columns that are JuMP decision variables.</p><p><strong>Keyword arguments</strong></p><p>All keyword arguments are passed to the corresponding <a href="#add_predictor"><code>add_predictor</code></a> of the GLM extension.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DataFrames, GLM, JuMP, MathOptAI

julia&gt; train_df = DataFrames.DataFrame(x1 = rand(10), x2 = rand(10));

julia&gt; train_df.y = 1.0 .* train_df.x1 + 2.0 .* train_df.x2 .+ rand(10);

julia&gt; predictor = GLM.lm(GLM.@formula(y ~ x1 + x2), train_df);

julia&gt; model = Model();

julia&gt; test_df = DataFrames.DataFrame(
           x1 = rand(6),
           x2 = @variable(model, [1:6]),
       );

julia&gt; test_df.y, _ = MathOptAI.add_predictor(model, predictor, test_df);

julia&gt; test_df.y
6-element Vector{VariableRef}:
 moai_Affine[1]
 moai_Affine[1]
 moai_Affine[1]
 moai_Affine[1]
 moai_Affine[1]
 moai_Affine[1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/ext/MathOptAIStatsModelsExt.jl#L14-L65">source</a></section></details></article><h2 id="Extensions"><a class="docs-heading-anchor" href="#Extensions">Extensions</a><a id="Extensions-1"></a><a class="docs-heading-anchor-permalink" href="#Extensions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.add_variables"><a class="docstring-binding" href="#MathOptAI.add_variables"><code>MathOptAI.add_variables</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">add_variables(
    model::JuMP.AbstractModel,
    x::Vector,
    n::Int,
    base_name::String,
)::Vector</code></pre><p>Add a vector of <code>n</code> variables to <code>model</code> with the base name <code>base_name</code>.</p><p><strong>Extensions</strong></p><p>This function is a hook for JuMP extensions to interact with MathOptAI.</p><p>Implement this method for subtypes of <code>model</code>  and <code>x</code> as needed.</p><p>The default method is:</p><pre><code class="language-julia hljs">function add_variables(
    model::JuMP.AbstractModel,
    x::Vector,
    n::Int,
    base_name::String,
)
    return JuMP.@variable(model, [1:n], base_name = base_name)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/extension.jl#L7-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptAI.get_variable_bounds"><a class="docstring-binding" href="#MathOptAI.get_variable_bounds"><code>MathOptAI.get_variable_bounds</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_variable_bounds(x::JuMP.AbstractVariableRef)</code></pre><p>Return a tuple corresponding to the <code>(lower, upper)</code> variable bounds of <code>x</code>.</p><p>If there is no bound, the value returned is <code>missing</code>.</p><p><strong>Extensions</strong></p><p>This function is a hook for JuMP extensions to interact with MathOptAI.</p><p>Implement this method for subtypes of <code>x</code> as needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/extension.jl#L44-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptAI.set_variable_bounds"><a class="docstring-binding" href="#MathOptAI.set_variable_bounds"><code>MathOptAI.set_variable_bounds</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_variable_bounds(
    cons::Vector{Any},
    x::JuMP.AbstractVariableRef,
    l::Any,
    u::Any;
    optional::Bool,
)</code></pre><p>Set the bounds on <code>x</code> to <code>l</code> and <code>u</code>, and <code>push!</code> their corresponding constraint references to <code>cons</code>.</p><p>If <code>l</code> or <code>u</code> are <code>missing</code>, do not set the bound.</p><p>If <code>optional = true</code>, you may choose to silently skip setting the bounds because they are not required for correctness.</p><p>The type of <code>l</code> and <code>u</code> depends on <a href="#MathOptAI.get_variable_bounds"><code>get_variable_bounds</code></a>.</p><p><strong>Extensions</strong></p><p>This function is a hook for JuMP extensions to interact with MathOptAI.</p><p>Implement this method for subtypes of <code>x</code> as needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/extension.jl#L78-L102">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptAI.get_variable_start"><a class="docstring-binding" href="#MathOptAI.get_variable_start"><code>MathOptAI.get_variable_start</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_variable_start(x::JuMP.AbstractVariableRef)</code></pre><p>Get the primal starting value of <code>x</code>, or return <code>missing</code> if one is not set.</p><p>The return value of this function is propogated through the various <a href="#AbstractPredictor"><code>AbstractPredictor</code></a>s, and the primal start of new output variables is set using <a href="#MathOptAI.set_variable_start"><code>set_variable_start</code></a>.</p><p><strong>Extensions</strong></p><p>This function is a hook for JuMP extensions to interact with MathOptAI.</p><p>Implement this method for subtypes of <code>x</code> as needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/extension.jl#L134-L148">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptAI.set_variable_start"><a class="docstring-binding" href="#MathOptAI.set_variable_start"><code>MathOptAI.set_variable_start</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_variable_start(x::JuMP.AbstractVariableRef, start::Any)</code></pre><p>Set the primal starting value of <code>x</code> to <code>start</code>, or do nothing if <code>start</code> is <code>missing</code>.</p><p>The input value <code>start</code> of this function is computed by propogating the primal start of the input variables (obtained with <a href="#MathOptAI.get_variable_start"><code>get_variable_start</code></a>) through the various <a href="#AbstractPredictor"><code>AbstractPredictor</code></a>s.</p><p><strong>Extensions</strong></p><p>This function is a hook for JuMP extensions to interact with MathOptAI.</p><p>Implement this method for subtypes of <code>x</code> and <code>start</code> as needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/extension.jl#L161-L176">source</a></section></details></article><h2 id="replace_weights_with_variables"><a class="docs-heading-anchor" href="#replace_weights_with_variables"><code>replace_weights_with_variables</code></a><a id="replace_weights_with_variables-1"></a><a class="docs-heading-anchor-permalink" href="#replace_weights_with_variables" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptAI.replace_weights_with_variables"><a class="docstring-binding" href="#MathOptAI.replace_weights_with_variables"><code>MathOptAI.replace_weights_with_variables</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">replace_weights_with_variables(
    model::JuMP.AbstractModel,
    predictor::AbstractPredictor,
)</code></pre><p>Convert <code>predictor</code> with trained weights into a predictor in which the weights are JuMP decision variables.</p><p>This function is useful when you wish to use constrained optimization to train small to moderate neural networks.</p><div class="admonition is-warning" id="Warning-8bed6673b4f2a523"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-8bed6673b4f2a523" title="Permalink"></a></header><div class="admonition-body"><p>This function is experimental and it may change in any future release. If you use this feature, please open a GitHub issue and let us know your thoughts.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP, Flux, MathOptAI

julia&gt; chain = Flux.Chain(Flux.Dense(2 =&gt; 3), Flux.softmax);

julia&gt; model = Model();

julia&gt; @variable(model, x[i in 1:2] == i);

julia&gt; predictor = MathOptAI.build_predictor(chain)
Pipeline with layers:
 * Affine(A, b) [input: 2, output: 3]
 * SoftMax()

julia&gt; predictor = MathOptAI.replace_weights_with_variables(model, predictor)
Pipeline with layers:
 * Affine(A, b) [input: 2, output: 3]
 * SoftMax()

julia&gt; y, _ = MathOptAI.add_predictor(model, predictor, x);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathOptAI.jl/blob/8cb0e23c3168b413836a8bdec8255361a38767aa/src/replace_weights_with_variables.jl#L7-L47">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../developers/design_principles/">« Design principles</a><a class="docs-footer-nextpage" href="../release_notes/">Release notes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Thursday 26 February 2026 01:43">Thursday 26 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
